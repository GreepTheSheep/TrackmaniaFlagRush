/**
 *	CYLINDER HITBOX LIB
 *	Based on Cyclinder Hitbox Lib by domino54
 *	https://github.com/domino54/title-packs/blob/master/Scripts/Libs/domino54/TrackMania/CylinderHitbox.Script.txt
 *	Adjusted for TM2020 by Ze-Rax
 *
 *	This library allows to create virtual cylinder hitbox for
 *	the cars, adjust cylinder diameter and height from player
 *	rotation and car model size. Allows to check if hitboxes
 *	of two players touch.
 */

#Const Version			"2021-09-07"
#Const ScriptName		"CylinderHitbox.Script.txt"

#Include "AnimLib" as AnimLib
#Include "MathLib" as MathLib

// ---------------------------------- //
// Structs
// ---------------------------------- //
#Struct Struct_Hitbox {
	Vec3 Center;
	Real Diameter;
	Real Height;
}

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_DetectionDistance		8.		///< Computes only if distance is smaller than this value
#Const C_VerticalSizeSub			.25		///< Short cylinder diameter to make it more accurate at car longer side

/// Sizes of visible player car models
#Const C_CarModelSizes [
	"CanyonCar"		=> <4.25, 1.125, 2.>,		// Leftover from TM2
	"StadiumCar"	=> <4., 1., 1.75>,			// Leftover from TM2
	"ValleyCar"		=> <4.25, 1.25, 2.25>,	// Leftover from TM2
	"CarSport"		=> <4., 1., 1.75>
]

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //

/** Convert pitch in radians to degress
 *
 *	@param	_Pitch		The pitch to convert
 *
 *	@return		Pitch converted to degress
 */
Real Private_GetPitch(Real _Pitch) {
	return MathLib::Abs(_Pitch * 2 / MathLib::PI());
}

// ---------------------------------- //
/** Get cylinder diameter
 *
 *	@param	_Pitch		Pitch used to compute diameter
 *
 *	@return		Diameter of cylinder
 */
Real Private_GetCyliDiameter(Real _Pitch) {
	return AnimLib::Ease("EaseInCirc", _Pitch, 1., -1., 1.);
}

// ---------------------------------- //
/** Get cylinder height
 *
 *	@param	_Pitch		Pitch used to compute height
 *
 *	@return		Height of cylinder
 */
Real Private_GetCyliHeight(Real _Pitch) {
	return AnimLib::Ease("EaseOutCirc", _Pitch, 0., 1., 1.);
}

// ---------------------------------- //
/** Distance between two points in one dimension
 *
 *	@param	_Pos1		Pirst point position
 *	@param	_Pos2		Second point position
 *
 *	@return		Distance between points
 */
Real Private_Distance1D(Real _Pos1, Real _Pos2) {
	return MathLib::Sqrt(MathLib::Pow(_Pos2 - _Pos1, 2.));
}

// ---------------------------------- //
/** Distance between two points in two dimensions
 *
 *	@param	_Pos1		Pirst point position
 *	@param	_Pos2		Second point position
 *
 *	@return		Distance between points
 */
Real Private_Distance2D(Vec3 _Pos1, Vec3 _Pos2) {
	return MathLib::Sqrt(MathLib::Pow(_Pos2.X - _Pos1.X, 2.) + MathLib::Pow(_Pos2.Z - _Pos1.Z, 2.));
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script
 *
 *	@return		The version number of the script
 */
Text GetScriptVersion() {
	return Version;
}

// ---------------------------------- //
/** Return the name of the script
 *
 *	@return		The name of the script
 */
Text GetScriptName() {
	return ScriptName;
}

// ---------------------------------- //
/** Check if a player is spawn
 *
 *	@param	_Player		Player to check spawn status of
 *
 *	@return		True if player is spawned, else False
 */
Boolean IsSpawned(CSmPlayer _Player) {
	if (_Player == Null) return False;
	if (_Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) return True;
	return False;
}

// ---------------------------------- //
/** Check if hitboxes of two players touch
 *
 *	@param	_Player1	First point position
 *	@param	_Player2	Second point position
 *
 *	@return		True if cylinders touch
 */
Boolean AreTouching(CSmPlayer _Player1, CSmPlayer _Player2) {
	if (_Player1 == Null || _Player2 == Null) return False;
	if (!IsSpawned(_Player1) || !IsSpawned(_Player2)) return False;
	if (_Player1.Position == <0., 0., 0.> || _Player2.Position == <0., 0., 0.>) return False;
	if (!C_CarModelSizes.existskey(MapPlayerModelName)) return False;
	
	// ---------------------------------- //
	// Check if cars are close enough
	if (MathLib::Distance(_Player1.Position, _Player2.Position) > C_DetectionDistance) return False;
	
	// ---------------------------------- //
	// Set hitbox model properties	
	declare Vec3 FixedPos1 = _Player1.Position;
	declare Vec3 FixedPos2 = _Player2.Position;
	
	FixedPos1.Y += C_CarModelSizes[MapPlayerModelName].Y / 2;
	FixedPos2.Y += C_CarModelSizes[MapPlayerModelName].Y / 2;
	
	// ---------------------------------- //
	// Convert rad to deg pitch
	declare Real Player1Pitch = Private_GetPitch(_Player1.AimPitch);
	declare Real Player2Pitch = Private_GetPitch(_Player2.AimPitch);
	
	// ---------------------------------- //
	// Cylinder diameter depends on player rotation
	declare Real Player1Diameter;
	Player1Diameter = (C_CarModelSizes[MapPlayerModelName].X - C_VerticalSizeSub) * Private_GetCyliDiameter(Player1Pitch);
	declare Real Player2Diameter;
	Player2Diameter = (C_CarModelSizes[MapPlayerModelName].X - C_VerticalSizeSub) * Private_GetCyliDiameter(Player2Pitch);
	
	// ---------------------------------- //
	// Diameter can't be shorter than vehicle width
	if (Player1Diameter < C_CarModelSizes[MapPlayerModelName].Z) Player1Diameter = C_CarModelSizes[MapPlayerModelName].Z;
	if (Player2Diameter < C_CarModelSizes[MapPlayerModelName].Z) Player2Diameter = C_CarModelSizes[MapPlayerModelName].Z;
	
	// ---------------------------------- //
	// Check if cylinders touch in X and Z axis
	if (Private_Distance2D(FixedPos1, FixedPos2) > (Player1Diameter + Player2Diameter) / 2) return False;
	
	// ---------------------------------- //
	// Cylinder height depends on player rotation
	declare Real Player1Height = C_CarModelSizes[MapPlayerModelName].X * Private_GetCyliHeight(Player1Pitch);
	declare Real Player2Height = C_CarModelSizes[MapPlayerModelName].X * Private_GetCyliHeight(Player2Pitch);
	
	// ---------------------------------- //
	// Height can't be lower then vehicle height
	if (Player1Height < C_CarModelSizes[MapPlayerModelName].Y) Player1Height = C_CarModelSizes[MapPlayerModelName].Y;
	if (Player2Height < C_CarModelSizes[MapPlayerModelName].Y) Player2Height = C_CarModelSizes[MapPlayerModelName].Y;
	
	// ---------------------------------- //
	// Check if cylinders touch in Y axis
	if (Private_Distance1D(FixedPos1.Y, FixedPos2.Y) - (C_VerticalSizeSub * 2) > (Player1Height + Player2Height) / 2) return False;
	
	// ---------------------------------- //
	// Players touch
	return True;
}

// ---------------------------------- //
/** Get the cylinder hitbox of a Player
 *
 *	@param	_Player	The player to get the hitbox of
 *
 *	@return		Hitbox struct of the player
 */
Struct_Hitbox GetHitbox(CSmPlayer _Player) {
	// Check if player is valid
	if (_Player == Null
				|| !IsSpawned(_Player)
				|| _Player.Position == <0., 0., 0.>
				|| !C_CarModelSizes.existskey(MapPlayerModelName)
	) return Struct_Hitbox{Center = <0., 0., 0.>, Diameter = 0., Height = 0.};
	
	declare Real PlayerPitch = Private_GetPitch(_Player.AimPitch);
	
	// Get Center
	declare Vec3 Center = _Player.Position;
	Center.Y += C_CarModelSizes[MapPlayerModelName].Y / 2;
	
	// Get Diameter
	declare Real Diameter = (C_CarModelSizes[MapPlayerModelName].X - C_VerticalSizeSub) * Private_GetCyliDiameter(PlayerPitch);
	if (Diameter < C_CarModelSizes[MapPlayerModelName].Z) Diameter = C_CarModelSizes[MapPlayerModelName].Z;
	
	// Get Height
	declare Real Height = C_CarModelSizes[MapPlayerModelName].X * Private_GetCyliHeight(PlayerPitch);
	if (Height < C_CarModelSizes[MapPlayerModelName].Y) Height = C_CarModelSizes[MapPlayerModelName].Y;
	
	// Return result
	return Struct_Hitbox{Center = Center, Diameter = Diameter, Height = Height};
}

Boolean CheckOverlap(Struct_Hitbox Hitbox1, Struct_Hitbox Hitbox2) {
	if (Hitbox1.Diameter <= 0. || Hitbox2.Diameter <= 0. || Hitbox1.Height <= 0. || Hitbox2.Height <= 0.) return False;
	
	// Check X & Z
	if (Private_Distance2D(Hitbox1.Center, Hitbox2.Center) > (Hitbox1.Diameter + Hitbox2.Diameter) / 2) return False;
	// Check Y
	if (Private_Distance1D(Hitbox1.Center.Y, Hitbox2.Center.Y) - (C_VerticalSizeSub * 2) > (Hitbox1.Height + Hitbox2.Height) / 2) return False;
	
	return True;
}

Vec3 GetCarSize(Text ModelName) {
	return C_CarModelSizes.get(ModelName, <0., 0., 0.>);
}