// #RequireContext CSmMode

/**
 * FlagRush
 * Gamemode by Ze-Rax, Reaby & Geekid
 */

#Extends "Libs/Zrx/ModeLibs/BaseModes/TeamFlagModeBase.Script.txt"

/* Common Libs */

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "ColorLib" as CL

#Include "Libs/Zrx/ModeLibs/Common/WarmUpReadyUp/WarmUpReadyUp.Script.txt" as WarmUpReadyUp
#Include "Libs/Zrx/ModeLibs/Common/Commands/ModeCommands.Script.txt" as ModeCommands
#Include "Libs/Zrx/ModeLibs/Common/Commands/CommandUtils.Script.txt" as CommandUtils
#Include "Libs/Zrx/ModeLibs/Common/ClubTagUtils.Script.txt" as ClubTagUtils
#Include "Libs/Zrx/ModeLibs/Common/Collision/CylinderHitbox.Script.txt" as Hitbox

/* FlagRush Libs */

#Include "Libs/Zrx/ModeLibs/FlagRush/FlagRush_Common.Script.txt" as FlagRush_Common

/* UI */

#Include "Libs/Zrx/ModeLibs/Common/EventFeed.Script.txt" as EventFeed
#Include "Libs/Zrx/ModeLibs/FlagRush/UI/Flash.Script.txt" as FlagRush_UIFlash
#Include "Libs/Zrx/ModeLibs/FlagRush/UI/Header.Script.txt" as FlagRush_UIHeader
#Include "Libs/Zrx/ModeLibs/FlagRush/UI/Markers.Script.txt" as FlagRush_UIMarkers
#Include "Libs/Zrx/ModeLibs/FlagRush/UI/Scoretable.Script.txt" as FlagRush_UIScoretable

/* Additional dependencies from other extends */

#Include "Libs/Zrx/ModeLibs/Common/Collision/Collision.Script.txt" as Collision
#Include "Libs/Zrx/ModeLibs/Common/PlayerTelemetry.Script.txt" as Telemetry
#Include "Libs/Zrx/ModeLibs/Common/TeamPointsProgression.Script.txt" as TeamPointsProgression

/* Constants */

#Const	CompatibleMapTypes						"Trackmania\\FlagRushArena,FlagRushArena"
#Const	Version												"2021-09-02"
#Const	ScriptName										"Modes/TrackMania/FlagRush.Script.txt"

#Const	C_SpawnAnimDuration						2000
#Const	C_BigMessage_Duration					3000

#Const	C_LayerName_ScoresTable				"Layer_FlagRush_ScoresTable"
#Const	C_LayerName_ScoresHeader			"Layer_FlagRush_ScoresHeader"
#Const	C_LayerName_RoundUI						"Layer_FlagRush_RoundUI"
#Const	C_LayerName_Markers						"Layer_FlagRush_Markers"
#Const 	C_LayerName_Feed							"Layer_FlagRush_Feed"
#Const 	C_LayerName_Flash							"Layer_FlagRush_Flash"
#Const	C_LayerName_ModeCommands			"Layer_ModeCommands"

#Const	C_Telemetry_Key_FlagsScored		"FlagsScored"
#Const	C_Telemetry_Key_FlagsStolen		"FlagsStolen"

#Const	C_FlagHitbox_Diameter					6.
#Const	C_FlagHitbox_Height						4.
#Const 	C_RespawnSpeedLimitKmh 				30.

#Const  C_Debug 											True
#Const	C_Debug_MarkersLabels					True
#Const	C_Debug_NbFakeUsers						<0, 0>

//////////////
// Settings //
//////////////

// Match progression
#Setting S_UseWarmUp												True		as _("Use warm up")

#Setting S_NbMapsToWinMatch									1 			as "Number of maps to win a match"
#Setting S_NbRoundsToWinMap									2 			as "Number of rounds to win a map"
#Setting S_NbFlagsToWinRound								3				as "Number of flags scored to win a round"
#Setting S_RoundTimeLimitSeconds						600 		as "Round Timelimit (seconds)"
#Setting S_UseTurns													False 	as "Use turns (Reset after a player scores a flag)"
#Setting S_UseOvertime											True 		as _("Use overtime when round is tied")

// Gameplay
#Setting S_UseReversedBases									False 	as "<hidden>" // Switch team bases
#Setting S_RandomizeFlagspawn								True 		as "Randomize flag spawn location"
#Setting S_FlagInitialSpawnDelaySeconds			0. 			as "<hidden>" // Initial flag spawn delay (seconds)
#Setting S_FlagRespawnDelaySeconds					0. 			as "<hidden>" // Flag respawn delay (seconds)
#Setting S_FlagDropStateDurationSeconds			8. 			as "Flag drop state duration (seconds)"
#Setting S_FlagStealResistDurationSeconds		1. 			as "<hidden>" // Flag steal resistance (seconds)
#Setting S_FlagSameTeamSteal								False 	as "Team flag steal"
#Setting S_FlagCarrierFragile								False 	as "Flag carrier becomes fragile"
#Setting S_FlagCarrierAcceleration					0.8 		as "Flag carrier acceleration (0.0 - 1.0)"
#Setting S_FlagCarrierControl								1.0 		as "<hidden>" // Flag carrier steering control (0.0 - 1.0)
#Setting S_FlagCarrierAdherence							1.0 		as "<hidden>" // Flag carrier adherence (0.0 - 1.0)
#Setting S_CanJoinMidRound									True 		as "<hidden>" // Players can join in the middle of a round
#Setting S_RespawnWhenStill									True 		as "Players can respawn only when being still"
#Setting S_RespawnDelay											1.5 		as "Respawn Delay (seconds)"

// Teams
#Setting S_Team1Name 												"" 			as "Team 1 Name"
#Setting S_Team2Name 												"" 			as "Team 2 Name"
#Setting S_Team1Color 											"" 			as "Team 1 Color"
#Setting S_Team2Color 											"" 			as "Team 2 Color"

// ModeCommands
#Setting S_ModeCommands_AdminLoginsCsv 			"" 			as "<hidden>" // Admin logins for the mode commands ui

//////////////
// Commands //
//////////////

// Constants are used for Commands from other sources, like UI Events.
// Constants value has to be the same as the name of the respective command without the Command_ prefix.
// The Parameter for the Command has to be sent with the Event in the Params array.
// In case of Vec2/Vec3/Int2/Int3 commands, X, Y & Z each take a seperate entry in the params array.
#Command	Command_PauseRound		(Boolean) as	"Pause round"
#Const		C_Command_Pause											"PauseRound"

#Command	Command_EndWarmup			(Boolean) as 	"End warmup"
#Const		C_Command_EndWarmup									"EndWarmup"

// #Command	Command_SkipMap				(Boolean) as	"Skip map"
#Const		C_Command_SkipMap										"SkipMap"

#Command	Command_ResetFlag			(Boolean) as	"Reset flag"
#Const		C_Command_ResetFlag									"ResetFlag"

/////////////
// Structs //
/////////////

#Struct Struct_FlagState {
	CMapLandmark Landmark;
	Text CarrierLogin;
	Vec3 DropLocation;
	Integer PickupableDate;
}

//////////////////////
// Global Variables //
//////////////////////

/* Match Progression */

declare Boolean G_RoundValid;
declare Boolean G_MapValid;
declare Integer G_GameplayPhase;
declare Boolean G_PauseRequested;

/* General mid round */

declare CMapLandmark G_SpawnTeam1;
declare CMapLandmark G_SpawnTeam2;
declare CMapLandmark G_DefaultFlagSpawn;
declare CMapLandmark[] G_BasesTeam1;
declare CMapLandmark[] G_BasesTeam2;
declare CMapLandmark[] G_FlagSpawns;
declare CMapLandmark G_ActiveFlagSpawn;
declare Struct_FlagState G_FlagState;
declare Integer G_FlagSpawnCounter;

/* UI */
declare CUIConfigMarker G_FlagMarker;

///////////
// Plugs //
///////////

***Match_StartServer***
***
Race::UseCppRaceProgression(False);					// To make it possible to trigger checkpoints multiple times
UsePvECollisions = True;							// To force player visibility
UsePvPCollisions = False;
UseClans = True;
MB_Settings_UseDefaultHud = False;
MB_Settings_UseDefaultPodiumSequence = False;

ModeCommands::Load();
declare Text[] ModeCommandsAdminLogins = TL::Split(",", S_ModeCommands_AdminLoginsCsv);
foreach(Login in ModeCommandsAdminLogins) {
	ModeCommands::AddAdmin(Login);
}
ModeCommands::AddAdmin("W2ZNWNzVQV6z3hXuNgRMRg");
ModeCommands::AddQuickCommand(C_Command_EndWarmup, "Icons64x64_1", "ArrowGreen");
ModeCommands::AddQuickCommand(C_Command_Pause, "UICommon64_1", "Pause_light");
ModeCommands::AddQuickCommand(C_Command_SkipMap, "UICommon64_1", "GoLastFrame_light");
ModeCommands::AddQuickCommand(C_Command_ResetFlag, "UIConstruction_Buttons", "Validate");
***

***Match_StartMatch***
***
FlagRush_Log("Start Match");
EventFeed::SendMessage("Start Match", "info");
***

***Match_InitMap***
***
InitLandmarks();
Map::SetDefaultStart(G_SpawnTeam1);

InitUI();
InitPlayers();
UpdateTeams();
ResetFlag(-1, True);

G_MapValid = True;
G_FlagSpawnCounter = 0;
***

***Match_StartMap***
***
Users_SetNbFakeUsers(C_Debug_NbFakeUsers.X, C_Debug_NbFakeUsers.Y);

FlagRush_Log("Start Map");
EventFeed::SendMessage("Start Map", "info");
MB_Sleep(5000);

if(S_UseWarmUp) {
	FlagRush_Log("Warmup phase");
	ExecWarmUp();
}
***

***Match_InitRound***
***
G_RoundValid = True;
SwitchGameplayPhase(FlagRush_Common::C_GameplayPhase_Round);
InitPlayers();
InitMarkers();
UpdateTeams();

foreach(Player in Players) {
	declare Boolean PlayerCanSpawnMidRound for Player;
	PlayerCanSpawnMidRound = True;
}
***

***Match_StartRound***
***
FlagRush_Log("Start Round");
declare Text Message = "Round start";
EventFeed::SendMessage(Message, "info");
UIManager.UIAll.QueueMessage(C_BigMessage_Duration, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Default, 0);
UIManager.UIAll.SendChat("""Please report game mode bugs: $3af$l[https://discord.gg/J6ApdyRqEZ]FlagRush Discord$l $fffat playtest channel!""");
MB_Sleep(C_BigMessage_Duration);

StartTime = Now;
if(S_RoundTimeLimitSeconds > 0) {
	SetEndTime(Now + S_RoundTimeLimitSeconds * 1000 + C_SpawnAnimDuration);
} else {
	SetEndTime(-1);
}
***

***Match_StartTurn***
***
FlagRush_Log("Start Turn");

if(G_PauseRequested) {
	EventFeed::SendMessage("The round was paused", "info");
	declare Integer RoundTimeLeft = EndTime - Now;
	ExecWarmUp();
	G_PauseRequested = False;
	SetEndTime(Now + RoundTimeLeft + C_SpawnAnimDuration);
}

G_FlagSpawnCounter = 0;
EventFeed::SendMessage("Start Turn", "info");
ResetFlag(ML::NearestInteger(S_FlagInitialSpawnDelaySeconds * 1000 + C_SpawnAnimDuration), True);

SpawnPlayers();
***

***Match_EndTurn***
***
FlagRush_Log("End Turn");
EventFeed::SendMessage("End Turn", "info");
UpdateScoresData();
UpdateFlagMarker(-1);

foreach(Player in Players) {
	UnspawnPlayer(Player);
}

declare Integer PreviousEndTime = EndTime;
SetEndTime(-1);
MB_Sleep(C_BigMessage_Duration);
SetEndTime(EndTime + C_BigMessage_Duration);
***

***Match_EndRound***
***
FlagRush_Log("End Round");
EventFeed::SendMessage("End Round", "info");
UpdateScoresData();

SetEndTime(-1);
MB_ClearAllMessages();

// Evaluate Current Round
if (MatchEndRequested) G_RoundValid = False;
if (G_RoundValid) {
	declare Integer MessageDuration = 5000;
	declare Text Message;
	declare Integer RoundWinnerClan = EvaluateRound();
	
	// Draw
	if(RoundWinnerClan == 0) {
		Message = """The round was a draw!""";
	}
	else {	// There is a winning clan (1 or 2)
		TeamPointsProgression::AddClanRoundsWon(RoundWinnerClan, 1);
		declare Team <=> Teams[RoundWinnerClan - 1];
		declare Vec3 ColorPrimaryUI for Team = FlagRush_Common::C_DefaultNeutralColor;
		declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
		Message = """{{{ColorText}}}{{{Team.Name}}}$z won the round!""";
	}
	
	UIManager.UIAll.QueueMessage(MessageDuration, 2, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::EndRound, 0);
	EventFeed::SendMessage(Message, "info");
	// Update Scores & Telemetry
	Telemetry::AffectPlayersRoundToMapAndMatchTelemetry();
	Scores::AffectPlayersRoundToMapAndMatchPoints();
	
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	MB_Sleep(MessageDuration / 2);
	UpdateScoresData();	// Update scores with delay to show score changes on scoreboard and header
	MB_Sleep(MessageDuration / 2);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
} else {
	UIManager.UIAll.QueueMessage(C_BigMessage_Duration, 2, CUIConfig::EMessageDisplay::Big, "The round was skipped!", CUIConfig::EUISound::EndRound, 0);
	MB_Sleep(C_BigMessage_Duration);
}

// Check if map is finished
declare RoundWinsTeam1 = TeamPointsProgression::GetClanRoundsWon(1);
declare RoundWinsTeam2 = TeamPointsProgression::GetClanRoundsWon(2);
if(RoundWinsTeam1 >= S_NbRoundsToWinMap || RoundWinsTeam2 >= S_NbRoundsToWinMap) {
	MB_StopMap();
}
***

***Match_EndMap***
***
FlagRush_Log("End Map");
EventFeed::SendMessage("End Map", "info");
UpdateScoresData();
if (MatchEndRequested) G_MapValid = False;
***

***Match_PodiumSequence***
***
UpdateScoresData();

// Evaluate Current Map
if (G_MapValid) {
	declare MessageDuration = S_ChatTime * 1000;
	declare Text Message;
	
	declare Integer MapWinnerClan = EvaluateMap();
	if(MapWinnerClan == 0) { // Draw
		Message = "The map was a draw!";
	}
	else {	// There is a winning clan (1 or 2)
		TeamPointsProgression::AddClanMapsWon(MapWinnerClan, 1);

		declare Team <=> Teams[MapWinnerClan - 1];
		declare Vec3 ColorPrimaryUI for Team = FlagRush_Common::C_DefaultNeutralColor;
		declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
		Message = """{{{ColorText}}}{{{Team.Name}}}$z won the map!""";
	}
	
	UIManager.UIAll.QueueMessage(MessageDuration, 2, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::EndRound, 0);
	EventFeed::SendMessage(Message, "info");
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	MB_Sleep(MessageDuration);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
} else {
	UIManager.UIAll.QueueMessage(C_BigMessage_Duration, 2, CUIConfig::EMessageDisplay::Big, "The map was skipped!", CUIConfig::EUISound::EndRound, 0);
	MB_Sleep(C_BigMessage_Duration);
}

// Check if match is finished
declare MapWinsTeam1 = TeamPointsProgression::GetClanMapsWon(1);
declare MapWinsTeam2 = TeamPointsProgression::GetClanMapsWon(1);
if(MapWinsTeam1 >= S_NbMapsToWinMatch || MapWinsTeam2 >= S_NbMapsToWinMatch)
{
	declare MessageDuration = S_ChatTime * 1000;
	declare Text Message;
	
	// Match_EndMatch is during Mapload, Finish here
	declare Integer MatchWinnerClan = EvaluateMatch();
	if(MatchWinnerClan == 0) {	// Draw? Someone set points that should not be set
		Message = "The match was a draw!";
	}
	else {	// There is a winning clan (1 or 2)
		declare WinnerTeam <=> Teams[MatchWinnerClan - 1];
		declare Vec3 ColorPrimaryUI for WinnerTeam = FlagRush_Common::C_DefaultNeutralColor;
		declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
		Message = """{{{ColorText}}}{{{WinnerTeam.Name}}}$z won the match!""";
	}
	UIManager.UIAll.QueueMessage(MessageDuration, 3, CUIConfig::EMessageDisplay::Big, Message,CUIConfig::EUISound::EndMatch, 0);
	EventFeed::SendMessage(Message, "info");
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	MB_Sleep(MessageDuration);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	
	MB_StopMatch();
}

Layers::DestroyAll();
***

***Match_EndMatch***
***
FlagRush_Log("End Match");
EventFeed::SendMessage("End Match", "info");
***

***Match_PlayLoop***
***
UpdateModeSettingValues();
UpdatePlayers();
UpdateSpectators();
UpdateFlag();
SpawnPlayers();
HandleEvents();
HandleCommands();

CheckRoundEndConditions();

if(G_PauseRequested) {
	MB_StopTurn();
}
***

// There's no public yield, so just use the private one
***MB_Private_Yield***
***
ModeCommands::Yield();
***

///////////////
// Functions //
///////////////

/**
 * Prefixed log.
 */
Void FlagRush_Log(Text Message) {
	if (C_Debug) log("[FlagRush] " ^ Message);
}

// --------------------------------------------------
// General helper functions
// --------------------------------------------------

/**
 * Gets the current flag carrier CSmPlayer by login.
 * Null if login not found.
 */
 CSmPlayer GetFlagCarrier() {
	return GetPlayer(G_FlagState.CarrierLogin);
}

// --------------------------------------------------
// Match Progression functions
// --------------------------------------------------

/**
 * Sets the EndTime but also sends it to the clients over netwrite
 */
Void SetEndTime(Integer _EndTime) {
	EndTime = _EndTime;
	declare netwrite Integer Net_EndTime for Teams[0];
	Net_EndTime = EndTime;
}

/**
 * Changes the current gameplay phase and reacts accordingly,
 */
Void SwitchGameplayPhase(Integer Phase) {
	G_GameplayPhase = Phase;
	declare netwrite Integer Net_GameplayPhase for Teams[0];
	Net_GameplayPhase = Phase;
}

/**
 * Checks if the conditions to end a round is met.
 */
Void CheckRoundEndConditions() {
	declare Integer RoundPointsTeam1 = Scores::GetClanRoundPoints(1);
	declare Integer RoundPointsTeam2 = Scores::GetClanRoundPoints(2);

	switch(G_GameplayPhase) {
		case FlagRush_Common::C_GameplayPhase_Round: {
			// Check Flags scores
			if (S_NbFlagsToWinRound > 0)
			{
				if (RoundPointsTeam1 >= S_NbFlagsToWinRound || RoundPointsTeam2 >= S_NbFlagsToWinRound) {
					MB_StopRound();
				}
			}

			// Check Timelimit
			if (S_RoundTimeLimitSeconds > 0) {
				if(Now > EndTime) {
					declare IsTie = RoundPointsTeam1 == RoundPointsTeam2;
				
					if(IsTie && S_UseOvertime) {
						SwitchGameplayPhase(FlagRush_Common::C_GameplayPhase_Overtime);
						declare Text Message = "$f90Overtime";
						EventFeed::SendMessage(Message, "info");
						UIManager.UIAll.QueueMessage(C_BigMessage_Duration, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Default, 0);
					} else {
						MB_StopRound();
					}
				}
			}
		}
		case FlagRush_Common::C_GameplayPhase_Overtime: {
			// Check flags scores
			if(RoundPointsTeam1 != RoundPointsTeam2) {
				MB_StopRound();
			}
		}
	}
}

/**
 * Evalutates the current round and determines the winner
 * @return Integer
 * 0 Draw
 * 1,2... for WinnerClan number
 */
Integer EvaluateRound() {
	declare Integer RoundPointsTeam1 = Scores::GetClanRoundPoints(1);
	declare Integer RoundPointsTeam2 = Scores::GetClanRoundPoints(2);
	
	declare Integer WinnerClan = 0;
	declare Integer RoundPointsDiff = RoundPointsTeam1 - RoundPointsTeam2;
	if(RoundPointsDiff > 0) WinnerClan = 1;
	else if (RoundPointsDiff < 0) WinnerClan = 2;
	
	return WinnerClan;
}

/**
 * Evalutates the current map and determines the winner
 * @return Integer
 * 0 for Draw
 * 1,2... for WinnerClan number
 */
Integer EvaluateMap() {
	declare Integer MapPointsTeam1 = TeamPointsProgression::GetClanRoundsWon(1);
	declare Integer MapPointsTeam2 = TeamPointsProgression::GetClanRoundsWon(2);
	
	declare Integer WinnerClan = 0;
	declare Integer MapPointsDiff = MapPointsTeam1 - MapPointsTeam2;
	if (MapPointsDiff > 0) WinnerClan = 1;
	else if (MapPointsDiff < 0) WinnerClan = 2;
	
	return WinnerClan;
}

/**
 * Evalutates the current match and determines the winner
 * @return Integer
 * 0 for Draw
 * 1,2... for WinnerClan number
 */
Integer EvaluateMatch() {
	declare Integer MatchPointsTeam1 = TeamPointsProgression::GetClanMapsWon(1);
	declare Integer MatchPointsTeam2 = TeamPointsProgression::GetClanMapsWon(2);
	
	declare Integer WinnerClan = 0;
	declare Integer MatchPointsDiff = MatchPointsTeam1 - MatchPointsTeam2;
	if (MatchPointsDiff > 0) WinnerClan = 1;
	else if (MatchPointsDiff < 0) WinnerClan = 2;
	
	return WinnerClan;
}

// --------------------------------------------------
// Update functions for conditional updates
// --------------------------------------------------

/**
 * Get the player scores
 */
 Integer[Text] GetPlayerScoresTableData(CSmScore Score) {
	declare Integer[Text] PlayerScoresTableData;
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsScoredKey] = Telemetry::GetPlayerMapInteger(Score, C_Telemetry_Key_FlagsScored);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsScoredRoundKey] = Telemetry::GetPlayerRoundInteger(Score, C_Telemetry_Key_FlagsScored);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsStolenKey] = Telemetry::GetPlayerMapInteger(Score, C_Telemetry_Key_FlagsStolen);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsStolenRoundKey] = Telemetry::GetPlayerRoundInteger(Score, C_Telemetry_Key_FlagsStolen);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_PointsKey] = Scores::GetPlayerMapPoints(Score);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_PointsRoundKey] = Scores::GetPlayerRoundPoints(Score);
	return PlayerScoresTableData;
}

/**
 * Collects scores table and header data and sends it to the clients via netwrite.
 */
Void UpdateScoresData() {
	/* General */
	declare netwrite Integer Net_NbMapsToWinMatch for Teams[0];
	Net_NbMapsToWinMatch = S_NbMapsToWinMatch;
	
	declare netwrite Integer Net_NbRoundsToWinMap for Teams[0];
	Net_NbRoundsToWinMap = S_NbRoundsToWinMap;
	
	for(Clan, 1, 2) {
		declare netwrite Integer Net_TeamRoundScore for Teams[Clan-1];
		Net_TeamRoundScore = Scores::GetClanRoundPoints(Clan);
		declare netwrite Integer Net_TeamMapScore for Teams[Clan-1];
		Net_TeamMapScore = TeamPointsProgression::GetClanRoundsWon(Clan);
	}

	/* Scores Table */

	// Looks scary, but: ClanIndex => [PlayerLogin => [ScoreFieldName => ScoreFieldValue]]
	declare Integer[Text][Text][Integer] ScoresTableData;
	declare Text[Text] ScoresTableNames = [];

	// Make sure no Index out of bounds error occurs
	for (I, 0, 2) ScoresTableData[I] = [];

	// Write each score into the array
	foreach (Score in Scores) {
		ScoresTableData[Score.TeamNum][Score.User.Login] = GetPlayerScoresTableData(Score);
		ScoresTableNames[Score.User.Login] = Score.User.Name;
	}

	// Send the data over netwrite
	// TODO: Is ScoresTableNames actually necessary? Could do login-to-name-conversion on client side; Reduces amount of netwrites/reads to manage
	declare netwrite Integer[Text][Text][Integer] Net_ScoresTableData for Teams[0];
	declare netwrite Text[Text] Net_ScoresTableNames for Teams[0];
	Net_ScoresTableData = ScoresTableData;
	Net_ScoresTableNames = ScoresTableNames;
	
	// Only update player ready states when in warmup
	if (G_GameplayPhase == FlagRush_Common::C_GameplayPhase_Warmup) {
		declare netwrite Boolean[Text] Net_WarmUpReadyStates for Teams[0];
		Net_WarmUpReadyStates = WarmUpReadyUp::GetPlayersReadyStates();
	}
}

/**
 * Updaates the dossard for a specific player.
 */
 Void UpdateDossard(CSmPlayer Player) {
	if (Player.CurrentClan <= 0) return;

	// Color
	declare Vec3 ColorPrimaryUI for Teams[Player.CurrentClan-1];
	Player.Dossard_Color = ColorPrimaryUI;
	Player.Dossard_Number = "0" ^ Player.CurrentClan;

	// Text
	declare FlagCarrier = GetFlagCarrier();
	if (FlagCarrier != Null) {
		if (FlagCarrier.Score.TeamNum == Player.CurrentClan) {
			Player.Dossard_Trigram = "OWN";
		} else {
			Player.Dossard_Trigram = "OPP";
		}
	} else {
		Player.Dossard_Trigram = "   ";
	}
	
	if (FlagCarrier != Null && FlagCarrier == Player) {
		Player.Dossard_Trigram = "FLG";
	}
}

/**
 * Updates the dossard for all players.
 */
Void UpdateDossards() {
	foreach (Player in Players) {
		UpdateDossard(Player);
	}
}

/**
 * Generated team configs for both teams based on the team settings and clubtags.
 */
ClubTagUtils::K_TeamConfig[] GetTeamConfigs() {
	declare Text G_Team1Name for This;
	declare Text G_Team1Color for This;
	declare Text G_Team2Name for This;
	declare Text G_Team2Color for This;
	
	// Get TeamConfigs from ClubTags
	declare ClubTagUtils::K_TeamConfig[] TeamConfigs;
	TeamConfigs.add(ClubTagUtils::GetTeamConfig(1));
	TeamConfigs.add(ClubTagUtils::GetTeamConfig(2));
	
	// Overwrite empty values or forced values
	if (TeamConfigs[0].Name == "" || G_Team1Name != "") TeamConfigs[0].Name = FlagRush_Common::GetDefaultTeamName(0);
	if (TeamConfigs[0].Color == ClubTagUtils::C_InvalidColor || G_Team1Color != "") TeamConfigs[0].Color = FlagRush_Common::GetDefaultTeamColor(0);
	if (TeamConfigs[1].Name == "" || G_Team2Name != "") TeamConfigs[1].Name = FlagRush_Common::GetDefaultTeamName(1);
	if (TeamConfigs[1].Color == ClubTagUtils::C_InvalidColor || G_Team2Color != "") TeamConfigs[1].Color = FlagRush_Common::GetDefaultTeamColor(1);
	
	// Adjust colors to avoid hue overlap
	// Only adjust if at least one team color is not forced by settings
	if(G_Team1Color == "" || G_Team2Color == "") {
		// If second is forced or second team uses ClubTag and first doesn't: Adjust first
		if(G_Team2Color != "" || TeamConfigs[1].ClubTag != "" && TeamConfigs[0].ClubTag == "") {
			TeamConfigs[0].Color = FlagRush_Common::GetTeam2ColorWithoutHueOverlap(TeamConfigs[1].Color, TeamConfigs[0].Color);
		}
		// If first is forced or first team uses ClubTag or none is forced or both use ClubTags: Adjust second
		else {
			TeamConfigs[1].Color = FlagRush_Common::GetTeam2ColorWithoutHueOverlap(TeamConfigs[0].Color, TeamConfigs[1].Color);
		}
	}
	
	return TeamConfigs;
}

/**
 * Configures both teams with names and colors according to settings or clubtags.
 */
Void UpdateTeams() {
	// Get TeamConfigs by ClubTag
	declare ClubTagUtils::K_TeamConfig[] TeamConfigs = GetTeamConfigs();

	// 0 is Team1, 1 is Team2 ("Team X" = Clan X = Teams[X-1])
	for(I, 0, 1) {
		Teams[I].Name = TeamConfigs[I].Name;
		declare Vec3 PrimaryColor = TeamConfigs[I].Color;
		
		// Teams have automatic change for colors; Need full saturation and value (HSV)
		Teams[I].ColorPrimary = FlagRush_Common::ColorToFullSaturationAndValue(PrimaryColor);
		Teams[I].ColorSecondary = FlagRush_Common::ColorToFullSaturationAndValue(PrimaryColor);
		
		// Use "declare for" for actual colors for UI. Player Markers still use Teams[I].ColorPrimary
		declare Vec3 ColorPrimaryUI for Teams[I];
		ColorPrimaryUI = PrimaryColor;
		
		declare netwrite Vec3 Net_PrimaryColor for Teams[I];
		Net_PrimaryColor = PrimaryColor;
	}

	UpdateScoresData();
	UpdateDossards();
}

/**
 * Sends the current flag carrier name and clan to UI clients
 */
Void UpdateFlagCarrier() {
	declare FlagCarrier = GetFlagCarrier();
	
	// Carrier Clan Index (for color)
	declare netwrite Integer Net_FlagCarrierClan for Teams[0];
	if (FlagCarrier == Null) Net_FlagCarrierClan = 0;
	else Net_FlagCarrierClan = FlagCarrier.CurrentClan;
	
	// Carrier name
	declare netwrite Text Net_FlagCarrierName for Teams[0];
	if (FlagCarrier != Null && FlagCarrier.User != Null) Net_FlagCarrierName = FlagCarrier.User.Name;
	else if (G_FlagState.Landmark == G_ActiveFlagSpawn) Net_FlagCarrierName = "Spawn";
	else Net_FlagCarrierName = "Dropped";

	UpdateDossards();
}

/**
 * Updates the UI flag marker for a player.
 */
Void UpdateFlagMarkerForPlayer(CSmPlayer Player) {
	// Hide marker for Carrier
	declare FlagCarrier = GetFlagCarrier();
	declare UI = UIManager.GetUI(Player);
	declare netwrite Boolean Net_HideFlagMarker for UI;
	if (FlagCarrier == Player && !C_Debug) Net_HideFlagMarker = True;
	else Net_HideFlagMarker = False;
}

/**
 * Updates the UI flag marker for each player (Color, Gauge).
 * Only in specific situations
 */
Void UpdateFlagMarker(Integer GaugeDuration) {
	// Timing for gauge
	declare ClampedGaugeDuration = GaugeDuration;
	if (ClampedGaugeDuration < 0) ClampedGaugeDuration = 0;
	declare netwrite Integer Net_FlagGaugeStartServerDate for Teams[0];
	Net_FlagGaugeStartServerDate = Now;
	declare netwrite Integer Net_FlagGaugeDuration for Teams[0];
	Net_FlagGaugeDuration = GaugeDuration;

	// Flag Carrier
	declare FlagCarrier = GetFlagCarrier();
	UpdateFlagCarrier();

	foreach(Player in AllPlayers) {
		UpdateFlagMarkerForPlayer(Player);
	}
}

// --------------------------------------------------
// Initialisation functions for StartTurn/Round/Map
// --------------------------------------------------

/**
 * Looks through all the landmarks on the map and set the global variables accordingly.
 */
 Void InitLandmarks() {
	FlagRush_Log("Initialising Landmarks...");
	G_FlagSpawnCounter = 0;
	G_FlagSpawns.clear();
	G_BasesTeam1.clear();
	G_BasesTeam2.clear();
	
	foreach (Landmark in MapLandmarks) {
		switch (Landmark.Tag) {
			case "SpawnTeam1": if (Landmark.PlayerSpawn != Null) G_SpawnTeam1 = Landmark;
			case "SpawnTeam2": if (Landmark.PlayerSpawn != Null) G_SpawnTeam2 = Landmark;
			case "BaseTeam1": if (Landmark.Waypoint != Null) G_BasesTeam1.add(Landmark);
			case "BaseTeam2": if (Landmark.Waypoint != Null) G_BasesTeam2.add(Landmark);
			case "FlagSpawn": if (Landmark.Waypoint != Null) G_FlagSpawns.add(Landmark);
			case "DefaultFlagSpawn": if (Landmark.Waypoint != Null) {
				G_FlagSpawns.add(Landmark);
				G_DefaultFlagSpawn = Landmark;
				G_ActiveFlagSpawn = Landmark;
			}
		}
	}
	
	declare FoundSpawnTeam1 = G_SpawnTeam1 != Null;
	declare FoundSpawnTeam2 = G_SpawnTeam2 != Null;
	declare FoundBaseTeam1 = G_BasesTeam1.count != 0;
	declare FoundBaseTeam2 = G_BasesTeam2.count != 0;
	declare FoundFlagSpawn = G_FlagSpawns.count != 0;
	declare FoundDefaultFlagSpawn = G_DefaultFlagSpawn != Null;
	
	assert(
		FoundSpawnTeam1 && FoundSpawnTeam2 && FoundBaseTeam1 && FoundBaseTeam2 && FoundFlagSpawn && FoundDefaultFlagSpawn,
		"""Couldn't init all landmarks!
		{{{"\t"}}}SpawnTeam1: {{{FoundSpawnTeam1}}}
		{{{"\t"}}}SpawnTeam2: {{{FoundSpawnTeam2}}}
		{{{"\t"}}}BaseTeam1 : {{{FoundBaseTeam1}}}
		{{{"\t"}}}BaseTeam2 : {{{FoundBaseTeam2}}}
		{{{"\t"}}}FlagSpawn : {{{FoundFlagSpawn}}}
		{{{"\t"}}}DefaultFlagSpawn : {{{FoundDefaultFlagSpawn}}}"""
	);
	
	FlagRush_Log("All Landmarks found!");
}

/**
 * Creates Markers for the bases and the flag for each player.
 */
Void InitMarkers() {
	declare Boolean InitAllFlags = G_GameplayPhase == FlagRush_Common::C_GameplayPhase_Warmup;

	// Clear old markers
	UIManager.UIAll.ClearMarkers();
	G_FlagMarker = Null;
	
	// Create Layer for all UIs
	declare Integer AmountOfBases = G_BasesTeam1.count;
	declare Integer FlagAmount = G_FlagSpawns.count;
	if (!InitAllFlags) FlagAmount = -1;
	
	Layers::Create(C_LayerName_Markers, FlagRush_UIMarkers::GetManialink(AmountOfBases, FlagAmount));
	Layers::SetType(C_LayerName_Markers, CUILayer::EUILayerType::Markers);
	Layers::Attach(C_LayerName_Markers);
	
	// Create Markers for the Flag and Bases
	for(I, 0, AmountOfBases-1) {
		declare MarkerBaseTeam1 = UIManager.UIAll.AddMarker(G_BasesTeam1[I]);
		MarkerBaseTeam1.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
		MarkerBaseTeam1.ManialinkFrameId = "marker-base-team1-" ^ I;
		MarkerBaseTeam1.Box = <0., 8., 0.>;
		// if (C_Debug_MarkersLabels) MarkerBaseTeam1.Label = "Base Team 1";
		
		declare MarkerBaseTeam2 = UIManager.UIAll.AddMarker(G_BasesTeam2[I]);
		MarkerBaseTeam2.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
		MarkerBaseTeam2.ManialinkFrameId = "marker-base-team2-" ^ I;
		MarkerBaseTeam2.Box = <0., 8., 0.>;
		// if (C_Debug_MarkersLabels) MarkerBaseTeam2.Label = "Base Team 2";
	}
	if (InitAllFlags) {
		foreach(I => FlagSpawn in G_FlagSpawns) {
			declare Marker = UIManager.UIAll.AddMarker(FlagSpawn);
			Marker.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
			Marker.ManialinkFrameId = "marker-flag-"^I;
			Marker.Box = <0., 3.3, 0.>;
		}
	} else {
		declare CSmPlayer FlagCarrier = GetFlagCarrier();
		if (FlagCarrier != Null) {
			if (G_FlagState.DropLocation != <0., 0., 0.>) {
				G_FlagMarker = UIManager.UIAll.AddMarker(G_FlagState.DropLocation);
				G_FlagMarker.ManialinkFrameId = "marker-flag";
				G_FlagMarker.Box = <0., 0., 0.>;
			} else {
				G_FlagMarker = UIManager.UIAll.AddMarker(FlagCarrier);
				G_FlagMarker.ManialinkFrameId = "marker-flag";
				G_FlagMarker.Box = <0., 1., 0.>;
			}
		}
		else {
			G_FlagMarker = UIManager.UIAll.AddMarker(G_ActiveFlagSpawn);
			G_FlagMarker.ManialinkFrameId = "marker-flag";
			G_FlagMarker.Box = <0., 3., 0.>;
		}
		G_FlagMarker.HudVisibility = CUIConfigMarker::EHudVisibility::Always;
		
	}
	
	foreach(CurrentPlayer in AllPlayers) {
		declare CUIConfig UI = UIManager.GetUI(CurrentPlayer);
		UI.ClearMarkers();
		UI.LabelsVisibility = CUIConfig::EHudVisibility::MarkersOnly;
		UI.LabelsVisibility_SkipMarkersOnly = True;
		UI.TeamLabelsShowNames = CUIConfig::EVisibility::None;
		UI.AlliesLabelsShowNames =  CUIConfig::EVisibility::None;
		UI.OpposingTeamLabelsShowNames = CUIConfig::EVisibility::None;
		UI.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
		UI.AlliesLabelsVisibility =  CUIConfig::ELabelsVisibility::Never;
		UI.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
		
		foreach(UIPlayer in Players) {
			if (UIPlayer != CurrentPlayer) {
				declare CUIConfigMarker Marker = UI.AddMarker(UIPlayer);
				Marker.Box = <0., 1., 0.>;
				declare Text Color = "$fff";
				
				Marker.Color = FlagRush_Common::GetDefaultTeamColor(UIPlayer.CurrentClan-1);
				Color = "$" ^ TL::ColorToText(FlagRush_Common::GetDefaultTeamColor(UIPlayer.CurrentClan-1));
				
				// Own Team
				if (CurrentPlayer.CurrentClan == UIPlayer.CurrentClan) {
					Marker.Label = UIPlayer.User.Name;
					Marker.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
				}
				// Their Team
				else {
					Marker.Label = UIPlayer.User.Name;
					Marker.HudVisibility = CUIConfigMarker::EHudVisibility::WhenVisible;
				}
			}
		}
	}
}

/**
 * Creates the UI for each player
 */
Void InitUI() {
	// Scores header
	Layers::Create(C_LayerName_ScoresHeader, FlagRush_UIHeader::GetManialink());
	Layers::SetType(C_LayerName_ScoresHeader, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_LayerName_ScoresHeader);
	
	// Scores table
	Layers::Create(C_LayerName_ScoresTable, FlagRush_UIScoretable::GetManialink(6));
	Layers::SetType(C_LayerName_ScoresTable, CUILayer::EUILayerType::ScoresTable);
	Layers::Attach(C_LayerName_ScoresTable);
	
	// Event Feed
	EventFeed::ClearMessages();
	Layers::Create(C_LayerName_Feed, EventFeed::GetManialink(10));
	Layers::SetType(C_LayerName_Feed, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_LayerName_Feed);
	
	// Flash
	Layers::Create(C_LayerName_Flash, FlagRush_UIFlash::GetManialink());
	Layers::SetType(C_LayerName_Flash, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_LayerName_Flash);
	
	// ModeCommands
	Layers::Create(C_LayerName_ModeCommands, ModeCommands::GetManialink());
	Layers::SetType(C_LayerName_ModeCommands, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_LayerName_ModeCommands);
	
	InitMarkers();
}

/**
 * Prepares players before rounds.
 */
Void InitPlayer(CSmPlayer Player) {
	Player.TrustClientSimu = True;
	Player.UseCrudeExtrapolation = True;
	declare Integer PreviousClan for Player;
	
	SetPlayerClan(Player, Player.RequestedClan);
	if (Player.RequestedClan != PreviousClan) {
		UpdateTeams();
	}
	
	PreviousClan = Player.RequestedClan;
}

/**
 * Inits all players.
 * @see InitPlayer(CSmPlayer Player)
 */
Void InitPlayers() {
	foreach (Player in Players) InitPlayer(Player);
}

// --------------------------------------------------
// Gameplay functions
// --------------------------------------------------

/**
 * Gets the right spawn for a given player.
 */
CMapSpawn GetPlayerSpawn(CSmPlayer Player) {
	if (Player == Null) return Null;
	
	declare	CMapSpawn PlayerSpawn;
	
	switch(Player.CurrentClan) {
		case 1: PlayerSpawn = G_SpawnTeam1.PlayerSpawn;
		case 2: PlayerSpawn = G_SpawnTeam2.PlayerSpawn;
		default: PlayerSpawn = Null;
	}
	
	return PlayerSpawn;
}

/**
 * Randomly choose a new flag spawn to activate if enabled.
 */
Void PickNewFlagSpawn() {
	G_FlagSpawnCounter += 1;

	if (G_FlagSpawnCounter == 1) {
		G_ActiveFlagSpawn = G_DefaultFlagSpawn;
		return;
	}
	
	if (S_RandomizeFlagspawn) {
		declare FlagSpawnToActivate = ML::Rand(0, G_FlagSpawns.count - 1);
		G_ActiveFlagSpawn = G_FlagSpawns[FlagSpawnToActivate];
	} else {
		G_ActiveFlagSpawn = G_DefaultFlagSpawn;
	}
}

Void SetFlagPositionAtSpawn(Integer PickupableDate) {
	// Update FlagState
	G_FlagState.Landmark = G_ActiveFlagSpawn;
	G_FlagState.PickupableDate = PickupableDate;
	G_FlagState.CarrierLogin = "";
	G_FlagState.DropLocation = <0., 0., 0.>;
	
	// Update flag marker
	if (G_FlagMarker != Null) {
		if(UIManager.UIAll.Markers.exists(G_FlagMarker))	// Check if marker exists (prevents warning)
		UIManager.UIAll.RemoveMarker(G_FlagMarker);			// Remove old
	}
	G_FlagMarker = UIManager.UIAll.AddMarker(G_ActiveFlagSpawn);
	G_FlagMarker.ManialinkFrameId = "marker-flag";
	G_FlagMarker.Box = <0., 3., 0.>;
	G_FlagMarker.HudVisibility = CUIConfigMarker::EHudVisibility::Always;
}

Void SetFlagPosition(CSmPlayer Player, Integer PickupableDate) {
	// Update FlagState
	G_FlagState.Landmark = Null;
	G_FlagState.PickupableDate = PickupableDate;
	G_FlagState.CarrierLogin = Player.User.Login;
	G_FlagState.DropLocation = <0., 0., 0.>;
	
	// Update flag marker
	UIManager.UIAll.RemoveMarker(G_FlagMarker);
	G_FlagMarker = UIManager.UIAll.AddMarker(Player);
	G_FlagMarker.ManialinkFrameId = "marker-flag";
	G_FlagMarker.Box = <0., 1., 0.>;
	G_FlagMarker.HudVisibility = CUIConfigMarker::EHudVisibility::Always;
}

Void SetFlagPosition(Vec3 Position, Integer PickupableDate) {
	// Update FlagState
	G_FlagState.Landmark = Null;
	G_FlagState.PickupableDate = PickupableDate;
	G_FlagState.CarrierLogin = "";
	G_FlagState.DropLocation = Position;
	
	// Update flag marker
	UIManager.UIAll.RemoveMarker(G_FlagMarker);
	G_FlagMarker = UIManager.UIAll.AddMarker(Position);
	G_FlagMarker.ManialinkFrameId = "marker-flag";
	G_FlagMarker.Box = <0., 0., 0.>;
	G_FlagMarker.HudVisibility = CUIConfigMarker::EHudVisibility::Always;
}

/**
 * Resets the flag to the flagspawn.
 */
Void ResetFlag(Integer RespawnDelay, Boolean Silent) {
	FlagRush_Log("The flag was reset!");
	
	// Display a message to all players
	if (!Silent) {
		declare Message = "The flag was reset!";
		UIManager.UIAll.QueueMessage(C_BigMessage_Duration, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Warning, 0);
		EventFeed::SendMessage(Message, "flag");
	}
	
	PickNewFlagSpawn();
	SetFlagPositionAtSpawn(Now + RespawnDelay);
	UpdateFlagMarker(RespawnDelay);
}

Void ResetFlag(Integer RespawnDelay) {
	ResetFlag(RespawnDelay, False);
}

Void ResetFlag(Boolean Silent) {
	ResetFlag(ML::NearestInteger(S_FlagRespawnDelaySeconds * 1000), Silent);
}

Void ResetFlag() {
	ResetFlag(ML::NearestInteger(S_FlagRespawnDelaySeconds * 1000));
}

/**
 * Applies all handicaps for a player
 */
Void ApplyHandicaps(CSmPlayer Player) {
	
	if (S_FlagCarrierControl != 1.) {
		while (SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_ControlCoef(Player, S_FlagCarrierControl);
	}
	
	if (S_FlagCarrierAcceleration != 1.) {
		while (SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_AccelCoef(Player, S_FlagCarrierAcceleration);
	}
	
	if (S_FlagCarrierAdherence != 1.) {
		while (SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_AdherenceCoef(Player, S_FlagCarrierAdherence);
	}
	
	if (S_FlagCarrierFragile) {
		while (SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_Fragile(Player, S_FlagCarrierFragile);
	}
}

/**
 * Reset all handicaps from a player
 */
Void ResetHandicaps(CSmPlayer Player) {
	while (SetPlayer_DelayedIsFull(Player)) MB_Yield();
	SetPlayer_Delayed_Reset(Player);
}

/**
 * Set a player as flag carrier. If player is Null, reset flag instead.
 */
Void SetFlagCarrier(CSmPlayer Player) {
	if(Player == Null) {
		ResetFlag();
		return;
	}
	
	FlagRush_Log("""{{{Player.User.Name}}} got the flag!""");
	
	// Display a message to all players
	MB_ClearAllMessages();
	declare Color = FlagRush_Common::C_DefaultNeutralColor;
	if(Player.CurrentClan > 0) {
		declare Team <=> Teams[Player.CurrentClan - 1];
		declare Vec3 ColorPrimaryUI for Team;
		Color = ColorPrimaryUI;
	}
	declare ColorText = "$" ^ CL::RgbToHex3(Color);
	declare Message = """{{{ColorText}}}{{{Player.User.Name}}}$z got the {{{ColorText}}}flag$z!""";
	UIManager.UIAll.QueueMessage(1500, 1, CUIConfig::EMessageDisplay::Big, Message,	CUIConfig::EUISound::Checkpoint, 0);
	EventFeed::SendMessage(Message, "flag", Color);
	
	// Update the flag carrier
	SetFlagPosition(Player, Now + ML::NearestInteger(S_FlagStealResistDurationSeconds * 1000));
	UpdateFlagMarker(ML::NearestInteger(S_FlagStealResistDurationSeconds * 1000));
	
	// Apply handicaps
	ApplyHandicaps(Player);
}

/**
 * Drops the flag at the current position of the carrier
 */
Void DropFlag() {
	declare CSmPlayer FlagCarrier = GetFlagCarrier();
	if(FlagCarrier == Null) return;
	
	FlagRush_Log("""{{{FlagCarrier.User.Name}}} dropped the flag!""");
	
	// Display a message to all players
	declare Vec3 Color = FlagRush_Common::C_DefaultNeutralColor;
	if(FlagCarrier.CurrentClan > 0)
	{
		declare Team <=> Teams[FlagCarrier.CurrentClan - 1];
		declare Vec3 ColorPrimaryUI for Team;
		Color = ColorPrimaryUI;
	}
	declare ColorText = "$" ^ CL::RgbToHex3(Color);
	declare Message = """{{{ColorText}}}{{{FlagCarrier.User.Name}}}$z dropped the {{{ColorText}}}flag$z!""";
	UIManager.UIAll.QueueMessage(1500, 1, CUIConfig::EMessageDisplay::Big, Message,	CUIConfig::EUISound::Checkpoint, 0);
	EventFeed::SendMessage(Message, "flag", Color);
	
	// Set the flag to the players position
	declare FlagPosition = FlagCarrier.Position;
	
	FlagPosition.Y += Hitbox::GetCarSize(MapPlayerModelName).Y / 2;
	SetFlagPosition(FlagCarrier.Position, Now + ML::NearestInteger(S_FlagDropStateDurationSeconds * 1000));
	UpdateFlagMarker(ML::NearestInteger(S_FlagDropStateDurationSeconds * 1000));
	
	// Reset Carrier handicaps
	ResetHandicaps(FlagCarrier);
}

/**
 * Handles what happens if a player scored a flag.
 */
Void ScoreFlag(CSmPlayer Player) {
	if(Player == Null) return;
	if(Player.CurrentClan < 1) return;
	
	FlagRush_Log("""{{{Player.User.Name}}} scored for {{{Teams[Player.CurrentClan - 1].Name}}}!""");
	
	// Display a message to all players
	MB_ClearAllMessages();
	declare Team <=> Teams[Player.CurrentClan - 1];
	declare Vec3 ColorPrimaryUI for Team;
	declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
	declare Teamname = Team.Name;
	declare Message = """{{{ColorText}}}{{{Player.User.Name}}}$z scored for {{{ColorText}}}{{{Teamname}}}$z!""";
	UIManager.UIAll.QueueMessage (C_BigMessage_Duration, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Finish, 0);
	EventFeed::SendMessage(Message, "flag", ColorPrimaryUI);
	// Add the points
	Scores::AddClanRoundPoints(Player.CurrentClan, 1);
	Scores::AddPlayerRoundPoints(Player.Score, FlagRush_Common::C_PointsValue_ScoreFlag);
	Telemetry::AddPlayerRoundInteger(Player.Score, C_Telemetry_Key_FlagsScored, 1);
	UpdateScoresData();
	
	ResetHandicaps(Player);
	ResetFlag(True);
	if(S_UseTurns) MB_StopTurn();
}

/**
 * Handles what happen if a player steals the flag of another player
 */
Void StealFlag(CSmPlayer NewCarrier, CSmPlayer OldCarrier) {
	if (NewCarrier == Null || OldCarrier == Null) return;
	
	declare FlagCarrier = GetFlagCarrier();
	
	if (FlagCarrier != OldCarrier) return;
	FlagRush_Log("""{{{NewCarrier.User.Name}}} stole the flag from {{{OldCarrier.User.Name}}}!""");
	
	if (NewCarrier.CurrentClan != OldCarrier.CurrentClan) {
		// Add the points only if the flag carrier is at different team!
		Scores::AddPlayerRoundPoints(NewCarrier.Score, FlagRush_Common::C_PointsValue_StealFlag);
		Telemetry::AddPlayerRoundInteger(NewCarrier.Score, C_Telemetry_Key_FlagsStolen, 1);
		UpdateScoresData();
	}
	
	// Reset old flag carrier handicaps
	ResetHandicaps(OldCarrier);
	
	// Set the new flag carrier
	SetFlagCarrier(NewCarrier);
}

/**
 * Spawns all players.
 */
Void SpawnPlayers() {
	foreach (Player in Players) {
		if (Player.Armor <= 0) {		// If Player has no armor, unspawn first (for example Offzone hit)
			if (Player.User.Login == G_FlagState.CarrierLogin)
			{
				DropFlag();
			}
			UnspawnPlayer(Player);	// Has to be done here, since Player in OnArmorEmpty Event in Null
		}
		
		// Spawn unspawned players
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
			declare Boolean PlayerCanSpawnMidRound for Player;
			if (S_CanJoinMidRound || PlayerCanSpawnMidRound || G_GameplayPhase == FlagRush_Common::C_GameplayPhase_Warmup) {
				declare CMapSpawn Spawn = GetPlayerSpawn(Player);
				if (Spawn != Null) {
					declare Integer SpawnDate for Player;
					InitPlayer(Player);
					if (SpawnDate <= Now) {
						SpawnPlayer(Player, Player.CurrentClan, 1, Spawn, Now + 2000);
						UpdateDossard(Player);
						SpawnDate = 0;
					}
				}
			}
		}
	}
}

/**
 * Updates the state of the flag every playloop if necessary
 */
Void UpdateFlag() {
	declare FlagIsDropped = GetFlagCarrier() == Null && G_FlagState.Landmark == Null;
	
	if (FlagIsDropped) {
		if (G_FlagState.PickupableDate < Now) {
			ResetFlag();
		}
		else {
			declare FlagHitbox = Hitbox::Struct_Hitbox {
				Center = G_FlagState.DropLocation,
				Diameter = C_FlagHitbox_Diameter,
				Height = C_FlagHitbox_Height
			};
			
			foreach (Player in Players) {
				if (Hitbox::CheckOverlap(FlagHitbox, Hitbox::GetHitbox(Player))) {
					SetFlagCarrier(Player);
					break;
				}
			}
		}
	}
}

/**
 * Updates ui and related things, if modeSetting changes
 */
Void UpdateModeSettingValues() {
	// Handle Team color and name changes
	declare Text G_Team1Color for This;
	declare Text G_Team2Color for This;
	declare Text G_Team1Name for This;
	declare Text G_Team2Name for This;
	
	declare Boolean NeedUpdate = False;
	if (S_Team1Name != G_Team1Name) {
		G_Team1Name = S_Team1Name;
		NeedUpdate = True;
	}
	
	if (S_Team2Name != G_Team2Name) {
		G_Team2Name = S_Team2Name;
		NeedUpdate = True;
	}
	if (S_Team1Color != G_Team1Color) {
		G_Team1Color = S_Team1Color;
		NeedUpdate = True;
	}
	if (S_Team2Color != G_Team2Color) {
		G_Team2Color = S_Team2Color;
		NeedUpdate = True;
	}
	
	if (NeedUpdate) {
		UpdateTeams();
	}
}

/**
 * Updates the players if ther state changed (Change team, ...).
 */
Void UpdatePlayers() {
	// Update Clan
	foreach (Player in Players) {
		if (Player.RequestedClan != Player.CurrentClan) {
			if (Player.User.Login == G_FlagState.CarrierLogin) DropFlag();
			UnspawnPlayer(Player);
			InitPlayer(Player);
		}
	}
}

/**
 * Make sure a player does not spawn mid round if setting is disabled
 */
Void UpdateSpectators() {
	foreach (Spectator in Spectators)
	{
		if (G_FlagState.CarrierLogin == Spectator.User.Login) DropFlag();
		declare Boolean PlayerCanSpawnMidRound for Spectator;
		PlayerCanSpawnMidRound = False;
	}
}

// --------------------------------------------------
// Event Handling
// --------------------------------------------------

/**
 * Loops though all events and reacts accordingly
 */
Void HandleEvents() {
	
	// Standard game events
	foreach(Event in PendingEvents) {
		// FlagRush_Log("Event: CSmModeEvent" ^ Event.Type);
		
		declare CSmPlayer FlagCarrier = GetFlagCarrier();
		
		switch(Event.Type) {
			case CSmModeEvent::EType::OnPlayerTriggersWaypoint: {
				if (Event.Landmark == G_ActiveFlagSpawn) {
					if (Event.Player != Null && FlagCarrier == Null && Now > G_FlagState.PickupableDate) {
						SetFlagCarrier(Event.Player);
					}
				} else if (G_BasesTeam1.exists(Event.Landmark)) {
					if (S_UseReversedBases) {
						if (Event.Player == FlagCarrier && Event.Player.CurrentClan == 1) ScoreFlag(Event.Player);
					} else {
						if (Event.Player == FlagCarrier && Event.Player.CurrentClan == 2) ScoreFlag(Event.Player);
					}
				} else if (G_BasesTeam2.exists(Event.Landmark)) {
					if (S_UseReversedBases) {
						if (Event.Player == FlagCarrier && Event.Player.CurrentClan == 2) ScoreFlag(Event.Player);
					} else {
						if (Event.Player == FlagCarrier && Event.Player.CurrentClan == 1) ScoreFlag(Event.Player);
					}
				}
			}
			
			case CSmModeEvent::EType::OnPlayerRequestRespawn:
			{
				declare Integer SpawnDate for Event.Player;
				if (S_RespawnWhenStill) {
					if (Event.Player.Speed < C_RespawnSpeedLimitKmh / 3.6) {
						SpawnDate = Now + ML::NearestInteger(S_RespawnDelay * 1000);
						UnspawnPlayer(Event.Player);
						if(FlagCarrier == Event.Player) DropFlag();
					} else {
						FlagRush_UIFlash::FlashRespawn(Event.Player);
					}
				} else {
					SpawnDate = Now + ML::NearestInteger(S_RespawnDelay * 1000);
					UnspawnPlayer(Event.Player);
					if(FlagCarrier == Event.Player) DropFlag();
				}
			}
			
			case CSmModeEvent::EType::OnPlayerAdded:
			{
				UpdateTeams();
			}
			
			case CSmModeEvent::EType::OnPlayerRemoved:
			{
				// Event.Player is Null; Only User available
				// This is the reason why Carrier in FlagState is not CSmPlayer
				if(G_FlagState.CarrierLogin == Event.User.Login) DropFlag();
				UpdateTeams();
			}
		}
	}
	
	// Collision detection using CylinderHitbox (based on Dommy's Lib)
	foreach (Event in Collision::GetPendingEvents()) {
		if (G_FlagState.PickupableDate < Now) {
			if (Event.Player1.CurrentClan != Event.Player2.CurrentClan || S_FlagSameTeamSteal) {
				declare FlagCarrier = GetFlagCarrier();
				if (FlagCarrier == Event.Player1) StealFlag(Event.Player2, Event.Player1);
				else if (FlagCarrier == Event.Player2) StealFlag(Event.Player1, Event.Player2);
			}
		}
	}

	// XmlRpc
	foreach (XmlRpcEvent in XmlRpc.PendingEvents) {
		switch (XmlRpcEvent.Type) {
			case CXmlRpcEvent::EType::CallbackArray: {
				switch (XmlRpcEvent.ParamArray1) {
					case "Trackmania.ForceEndRound": {
						G_RoundValid = False;
						MB_StopRound();
					}
				}
			}
		}
	}
}

/**
 * Handles a single command.
 */
Void HandleCommand(CommandUtils::K_Command Command) {
	switch(Command.Name) {
		case CommandUtils::C_CommandPrefix ^ C_Command_EndWarmup: {
			WarmUpReadyUp::Stop();
		}
		case CommandUtils::C_CommandPrefix ^ C_Command_Pause: {
			G_PauseRequested = True;
		}
		case CommandUtils::C_CommandPrefix ^ C_Command_SkipMap: {
			MatchEndRequested = True;
		}
		case CommandUtils::C_CommandPrefix ^ C_Command_ResetFlag: {
			declare CSmPlayer FlagCarrier = GetPlayer(G_FlagState.CarrierLogin);
			if(FlagCarrier != Null) ResetHandicaps(FlagCarrier);
			ResetFlag();
		}
		case CommandUtils::C_CommandPrefix ^ "update": {
			UpdateScoresData();
		}
	}
}

/**
 * Handles (mode) commands, sent either through XmlRpc or UIEvents.
 */
Void HandleCommands() {
	foreach (Event in PendingEvents) {
		if (Event.Type == CSmModeEvent::EType::OnCommand) {
			HandleCommand(CommandUtils::FromEvent(Event));
		}
	}

	foreach (Command in ModeCommands::GetPendingCommands()) {
		HandleCommand(Command);
	}
}

// --------------------------------------------------
// WarmUp functions
// --------------------------------------------------

/**
 * Loops though all events and reacts accordingly.
 */
 Void HandleWarmUpEvents() {
	// Mode Events
	foreach(Event in PendingEvents) {
		declare CSmPlayer EventPlayer = Event.Player; // UnspawnPlayer Async? PendingEvents[X] reference becomes Null
		
		switch(Event.Type) {
			case CSmModeEvent::EType::OnPlayerTriggersWaypoint: {
				declare Vec3 Color = FlagRush_Common::GetDefaultTeamColor(Event.Player.CurrentClan);
				if (Event.Player != Null) {
					declare Boolean FlagRush_WarmUp_HasFlag for Event.Player = False;
					if (G_FlagSpawns.exists(Event.Landmark) && !FlagRush_WarmUp_HasFlag) {
						FlagRush_WarmUp_HasFlag = True;
						ApplyHandicaps(EventPlayer);
					} else if (G_BasesTeam1.exists(Event.Landmark) && Event.Player.CurrentClan == 2) {
						FlagRush_WarmUp_HasFlag = False;
						ResetHandicaps(EventPlayer);
					} else if (G_BasesTeam2.exists(Event.Landmark) && Event.Player.CurrentClan == 1) {
						FlagRush_WarmUp_HasFlag = False;
						ResetHandicaps(EventPlayer);
					}
				}
			}
			case CSmModeEvent::EType::OnPlayerRequestRespawn:
			{
				
				declare Boolean FlagRush_WarmUp_HasFlag for Event.Player;
				FlagRush_WarmUp_HasFlag = False;
				ResetHandicaps(EventPlayer);
				UnspawnPlayer(EventPlayer);
			}
			case CSmModeEvent::EType::OnPlayerAdded:
			{
				InitPlayer(Event.Player);
			}
		}
	}

	// WarmUpReadyUp Events
	foreach (WuruEvent in WarmUpReadyUp::GetPendingEvents()) {
		// Refrech EndTime net variable when it's updated by WURU
		if(WuruEvent.Type == WarmUpReadyUp::C_Event_Type_TimeoutStart
			|| WuruEvent.Type == WarmUpReadyUp::C_Event_Type_TimeoutUpdate
			|| WuruEvent.Type == WarmUpReadyUp::C_Event_Type_TimeoutAbort) {
			SetEndTime(EndTime);
		} else if (WuruEvent.Type == WarmUpReadyUp::C_Event_Type_PlayerReadyChanged) {
			UpdateScoresData();
		}
	}
}

/**
 * Handles the whole warmup process.
 */
Void ExecWarmUp() {
	FlagRush_Log("Start WarmUp");
	// Init everything for warmup
	Race::StopSkipOutroAll();
	declare Integer PreviousGameplayPhase = G_GameplayPhase;
	SwitchGameplayPhase(FlagRush_Common::C_GameplayPhase_Warmup);
	WarmUpReadyUp::Start();

	foreach(Player in AllPlayers) {
		declare Boolean FlagRush_WarmUp_HasFlag for Player;
		FlagRush_WarmUp_HasFlag = False;
	}
	InitPlayers();
	InitMarkers();
	UpdateTeams();
	
	StartTime = Now;
	SetEndTime(-1);
	
	declare PrevUISequence = UIManager.UIAll.UISequence;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

	// Show message
	declare Text Message = "$f90WarmUp";
	EventFeed::SendMessage(Message, "info");
	UIManager.UIAll.QueueMessage(C_BigMessage_Duration, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Default, 0);
	MB_Sleep(C_BigMessage_Duration);

	// Main WarmUp loop
	while(!WarmUpReadyUp::WarmUpShouldStop()) {
		MB_Yield();
		WarmUpReadyUp::Yield();
		UpdatePlayers();
		SpawnPlayers();
		HandleWarmUpEvents();
		HandleCommands();
	}
	
	// End warmup
	+++Warmup_EndWarmUp+++
	FlagRush_Log("End WarmUp");
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;

	// Show message
	Message = "$f90WarmUp End";
	UIManager.UIAll.QueueMessage(C_BigMessage_Duration, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Default, 0);
	EventFeed::SendMessage(Message, "info");
	MB_Sleep(3000);

	// Cleanup
	SwitchGameplayPhase(PreviousGameplayPhase);
	UIManager.UIAll.UISequence = PrevUISequence;
	InitMarkers();
	foreach(Player in Players) {
		UnspawnPlayer(Player);
	}
}