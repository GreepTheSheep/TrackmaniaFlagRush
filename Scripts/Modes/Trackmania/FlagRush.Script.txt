// #RequireContext CSmMode

/**
*	FlagRush
*	Gamemode by Ze-Rax
*/

#Extends "Libs/Zrx/TeamFlagModeBase.Script.txt"

#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "ColorLib" as CL

#Include "Libs/Zrx/FlagRush/FlagRush_Common.Script.txt" as FlagRush_Common
#Include "Libs/Zrx/CylinderHitbox.Script.txt" as Hitbox

/* Additional dependencies from other extends */

#Include "Libs/Zrx/Collision.Script.txt" as Collision
#Include "Libs/Zrx/PlayerTelemetry.Script.txt" as Telemetry
#Include "Libs/Zrx/TeamPointsProgression.Script.txt" as TeamPointsProgression

/* UI */

#Include "Libs/Zrx/FlagRush/UI/Feed.Script.txt" as UIEventFeed
#Include "Libs/Zrx/FlagRush/UI/Flash.Script.txt" as FlagRush_UIFlash
#Include "Libs/Zrx/FlagRush/UI/Header.Script.txt" as FlagRush_UIHeader
#Include "Libs/Zrx/FlagRush/UI/Markers.Script.txt" as FlagRush_UIMarkers
#Include "Libs/Zrx/FlagRush/UI/Scoretable.Script.txt" as FlagRush_UIScoretable


#Include "Libs/Zrx/ModeCommandsUI.Script.txt" as CommandsUI

/* Constants */

#Const	CompatibleMapTypes  "TrackMania\\FlagRushArena,FlagRushArena"
#Const	Version				"2021-09-02"
#Const	ScriptName			"Modes/TrackMania/FlagRush.Script.txt"

#Const	C_LayerName_ScoresTable				"Layer_FlagRush_ScoresTable"
#Const	C_LayerName_ScoresHeader			"Layer_FlagRush_ScoresHeader"
#Const	C_LayerName_RoundUI					"Layer_FlagRush_RoundUI"
#Const	C_LayerName_Markers					"Layer_FlagRush_Markers"
#Const 	C_LayerName_Feed					"Layer_FlagRush_Feed"
#Const 	C_LayerName_Flash					"Layer_FlagRush_Flash"

#Const	C_Telemetry_Key_FlagsScored			"FlagsScored"
#Const	C_Telemetry_Key_FlagsStolen			"FlagsStolen"

#Const	C_FlagHitbox_Diameter				6.
#Const	C_FlagHitbox_Height					4.

#Const  C_Debug 							True
#Const	C_Debug_MarkersLabels				True
#Const	C_Debug_NbFakeUsers					<1, 1>
#Const	C_SpawnAnimDuration					1500
#Const 	C_RespawnSpeedLimitKmh 				30.

//////////////
// Settings //
//////////////

// Match progression
// #Setting S_UseWarmup											False as "Start each map with a warmup"

#Setting S_NbMapsToWinMatch							1 	as "Number of maps to win a match"
#Setting S_NbRoundsToWinMap							2 	as "Number of rounds to win a map"
#Setting S_NbFlagsToWinRound						3	as "Number of flags scored to win a round"
#Setting S_RoundTimeLimitSeconds					0 as "Round Timelimit (seconds)"
#Setting S_UseTurns									False as "Use turns (Reset after a player scores a flag)"

// Gameplay
#Setting S_UseReversedBases							False as "<hidden>" // Switch team bases
#Setting S_RandomizeFlagspawn						True as "Randomize flag spawn location"
#Setting S_FlagInitialSpawnDelaySeconds				0. as "<hidden>" // Initial flag spawn delay (seconds)
#Setting S_FlagRespawnDelaySeconds					0. as "<hidden>" // Flag respawn delay (seconds)
#Setting S_FlagDropStateDurationSeconds				8. as "Flag drop state duration (seconds)"
#Setting S_FlagStealResistDurationSeconds			1. as "<hidden>" // Flag steal resistance (seconds)
#Setting S_FlagSameTeamSteal						False as "Team flag steal"
#Setting S_FlagCarrierFragile						False as "Flag carrier becomes fragile"
#Setting S_FlagCarrierAcceleration					0.8 as "Flag carrier acceleration (0.0 - 1.0)"
#Setting S_FlagCarrierControl						1.0 as "<hidden>" // Flag carrier steering control (0.0 - 1.0)
#Setting S_FlagCarrierAdherence						1.0 as "<hidden>" // Flag carrier adherence (0.0 - 1.0)
#Setting S_CanJoinMidRound							True as "<hidden>" // Players can join in the middle of a round
#Setting S_RespawnWhenStill							True as "Players can respawn only when being still"
#Setting S_RespawnDelay								1.5 as "Respawn Delay (seconds)"

// Teams
#Setting S_Team1Name 								"" as "Force Team1 Name"
#Setting S_Team2Name 								"" as "Force Team2 Name"
#Setting S_Team1Color 								"" as "Force Team1 Color"
#Setting S_Team2Color 								"" as "Force Team2 Color"

/////////////
// Structs //
/////////////

#Struct Struct_FlagState {
	CMapLandmark Landmark;
	Text CarrierLogin;
	Vec3 DropLocation;
	Integer PickupableDate;
}

//////////////////////
// Global Variables //
//////////////////////

/* Match Progression */

declare Boolean G_RoundValid;
declare Boolean G_MapValid;

/* General mid round */

declare CMapLandmark G_SpawnTeam1;
declare CMapLandmark G_SpawnTeam2;
declare CMapLandmark[] G_BasesTeam1;
declare CMapLandmark[] G_BasesTeam2;
declare CMapLandmark[] G_FlagSpawns;
declare CMapLandmark G_ActiveFlagSpawn;
declare Struct_FlagState G_FlagState;

/* UI */
declare CUIConfigMarker G_FlagMarker;

///////////
// Plugs //
///////////

***Match_StartServer***
***
Race::UseCppRaceProgression(False);					// To make it possible to trigger checkpoints multiple times
UsePvECollisions = True;							// To force player visibility
UsePvPCollisions = False;
UseClans = True;
MB_Settings_UseDefaultPodiumSequence = False;

***

// --------------------------------------------------

***Match_StartMatch***
***
FlagRush_Log("Start Match");
UIEventFeed::SendMessage("Start Match", "info");
***

// --------------------------------------------------

***Match_InitMap***
***
InitLandmarks();
InitUI();
InitTeams();
UpdateUI();

// Update Flag marker so it does not show the gauge from last dates after InitUI
UpdateFlagMarker();

Map::SetDefaultStart(G_SpawnTeam1);
G_MapValid = True;

if(C_Debug) { 
	InitTestCommands();	
}
***

// --------------------------------------------------

***Match_StartMap***
***
FlagRush_Log("Start Map");
UIEventFeed::SendMessage("Start Map", "info");
MB_Sleep(5000);

Users_SetNbFakeUsers(C_Debug_NbFakeUsers.X, C_Debug_NbFakeUsers.Y);

***

// --------------------------------------------------

***Match_InitRound***
***
G_RoundValid = True;
InitPlayers();
InitMarkers();
UpdateUI();
foreach(Player in Players) {
	declare Boolean PlayerCanSpawnMidRound for Player;
	PlayerCanSpawnMidRound = True;
}
***

// --------------------------------------------------

***Match_StartRound***
***
FlagRush_Log("Start Round");

declare MessageDuration = 3000;
declare Message = """Round start!""";
UIManager.UIAll.QueueMessage(MessageDuration, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Default, 0);
UIEventFeed::SendMessage(Message, "info");
MB_Sleep(MessageDuration);

StartTime = Now;
EndTime = Now + S_RoundTimeLimitSeconds * 1000 + C_SpawnAnimDuration;
***

// --------------------------------------------------

***Match_StartTurn***
***
FlagRush_Log("Start Turn");

UIEventFeed::SendMessage("Start Turn", "info");
ResetFlag(ML::NearestInteger(S_FlagInitialSpawnDelaySeconds * 1000 + C_SpawnAnimDuration), True);

SpawnPlayers();
***

// --------------------------------------------------

***Match_EndTurn***
***
FlagRush_Log("End Turn");
UIEventFeed::SendMessage("End Turn");
UpdateUI();
UpdateFlagMarker();

foreach(Player in Players) {
	UnspawnPlayer(Player);
}

declare SleepDuration = 3000;
MB_Sleep(SleepDuration);
EndTime += SleepDuration;
***

// --------------------------------------------------

***Match_EndRound***
***
FlagRush_Log("End Round");
UIEventFeed::SendMessage("End Round", "info");
UpdateUI();

MB_ClearAllMessages();

// Evaluate Current Round
if (MatchEndRequested) G_RoundValid = False;
if (G_RoundValid) {	
	declare Integer MessageDuration = 5000;
	declare Text Message;	
	declare Integer RoundWinnerClan = EvaluateRound();
	
	// Draw
	if(RoundWinnerClan == 0) {
		Message = """The round was a draw!""";
	}
	else {	// There is a winning clan (1 or 2)
		TeamPointsProgression::AddClanRoundsWon(RoundWinnerClan, 1);
		declare Team <=> Teams[RoundWinnerClan - 1];
		declare Vec3 ColorPrimaryUI for Team = FlagRush_Common::C_DefaultNeutralColor;
		declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
		Message = """{{{ColorText}}}{{{Team.Name}}}$z won the round!""";
	}
	
	UIManager.UIAll.QueueMessage(MessageDuration, 2, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Record, 0);
	UIEventFeed::SendMessage(Message, "info");
	// Update Scores & Telemetry
	Telemetry::AffectPlayersRoundToMapAndMatchTelemetry();
	Scores::AffectPlayersRoundToMapAndMatchPoints();
	
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	MB_Sleep(MessageDuration / 2);
	UpdateUI();	// Update Scoreboard to show score changes
	MB_Sleep(MessageDuration / 2);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}

// Check if map is finished
declare RoundWinsTeam1 = TeamPointsProgression::GetClanRoundsWon(1);
declare RoundWinsTeam2 = TeamPointsProgression::GetClanRoundsWon(2);
if(RoundWinsTeam1 >= S_NbRoundsToWinMap || RoundWinsTeam2 >= S_NbRoundsToWinMap) {
	MB_StopMap();
}
***

// --------------------------------------------------

***Match_EndMap***
***
FlagRush_Log("End Map");
UIEventFeed::SendMessage("End Map", "info");
UpdateUI();

// Evaluate Current Map
if (MatchEndRequested) G_MapValid = False;
if (G_MapValid) {
	declare Integer MapWinnerClan = EvaluateMap();
	if(MapWinnerClan != 0) { // Not a draw	
		TeamPointsProgression::AddClanMapsWon(MapWinnerClan, 1);
	}
}
***

***Match_PodiumSequence***
***
UpdateUI();

// Evaluate Current Map
if (G_MapValid) {	
	declare MessageDuration = S_ChatTime * 1000;
	declare Text Message;
	
	declare Integer MapWinnerClan = EvaluateMap();
	if(MapWinnerClan == 0) { // Draw	
		Message = "The map was a draw!";
	}
	else {	// There is a winning clan (1 or 2)
		declare Team <=> Teams[MapWinnerClan - 1];
		declare Vec3 ColorPrimaryUI for Team = FlagRush_Common::C_DefaultNeutralColor;
		declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
		Message = """{{{ColorText}}}{{{Team.Name}}}$z won the map!""";
	}
	
	UIManager.UIAll.QueueMessage(MessageDuration, 2, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::EndRound, 0);
	UIEventFeed::SendMessage(Message, "info");
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	MB_Sleep(MessageDuration);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
}

// Check if match is finished
declare MapWinsTeam1 = TeamPointsProgression::GetClanMapsWon(1);
declare MapWinsTeam2 = TeamPointsProgression::GetClanMapsWon(1);
if(MapWinsTeam1 >= S_NbMapsToWinMatch || MapWinsTeam2 >= S_NbMapsToWinMatch)
{	
	declare MessageDuration = S_ChatTime * 1000;
	declare Text Message;
	
	// Match_EndMatch is during Mapload, Finish here
	declare Integer MatchWinnerClan = EvaluateMatch();
	if(MatchWinnerClan == 0) {	// Draw? Someone set points that should not be set
		Message = "The match was a draw!";
	}
	else {	// There is a winning clan (1 or 2)
		declare WinnerTeam <=> Teams[MatchWinnerClan - 1];
		declare Vec3 ColorPrimaryUI for WinnerTeam = FlagRush_Common::C_DefaultNeutralColor;
		declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
		Message = """{{{ColorText}}}{{{WinnerTeam.Name}}}$z won the match!""";
	}
	UIManager.UIAll.QueueMessage(MessageDuration, 3, CUIConfig::EMessageDisplay::Big, Message,CUIConfig::EUISound::EndMatch, 0);
	UIEventFeed::SendMessage(Message, "info");
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	MB_Sleep(MessageDuration);
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	
	MB_StopMatch();
}

Layers::DestroyAll();
***

***Match_EndMatch***
***
FlagRush_Log("End Match");
UIEventFeed::SendMessage("End Match", "info");
***

// --------------------------------------------------

***Match_PlayLoop***
***
UpdateModeSettingValues();
UpdatePlayers();
UpdateSpectators();
UpdateUI();
UpdateFlag();
SpawnPlayers();
HandleEvents();

CheckRoundEndConditions();

if(C_Debug) CheckTestCommands();
***

///////////////
// Functions //
///////////////

// --------------------------------------------------

/**
* Prefixed log.
*/
Void FlagRush_Log(Text Message) {
	if (C_Debug) log("[FlagRush] " ^ Message);
}

// --------------------------------------------------
// Match Progression functions
// --------------------------------------------------

/**
*	Checks if the conditions to end a round is met.
*/
Void CheckRoundEndConditions() {
	// Check Timelimit
	if (S_RoundTimeLimitSeconds > 0) if(Now > EndTime) MB_StopRound();
	
	// Check Flags scores
	if (S_NbFlagsToWinRound > 0)
	{
		declare Integer RoundPointsTeam1 = Scores::GetClanRoundPoints(1);
		declare Integer RoundPointsTeam2 = Scores::GetClanRoundPoints(2);
		if (RoundPointsTeam1 >= S_NbFlagsToWinRound || RoundPointsTeam2 >= S_NbFlagsToWinRound) MB_StopRound();
	}
}

// --------------------------------------------------

/**
* valutates the current round and determines the winner
* @return Integer
* 0 Draw
* 1,2... for WinnerClan number  
* 
*/
Integer EvaluateRound() {
	declare Integer RoundPointsTeam1 = Scores::GetClanRoundPoints(1);
	declare Integer RoundPointsTeam2 = Scores::GetClanRoundPoints(2);
	
	declare Integer WinnerClan = 0;
	declare Integer RoundPointsDiff = RoundPointsTeam1 - RoundPointsTeam2;
	if(RoundPointsDiff > 0) WinnerClan = 1;
	else if (RoundPointsDiff < 0) WinnerClan = 2;
	
	return WinnerClan;
}

// --------------------------------------------------

/**
* Evalutates the current map and determines the winner
* @return Integer
* 0 for Draw
* 1,2... for WinnerClan number 
*/
Integer EvaluateMap() {
	declare Integer MapPointsTeam1 = TeamPointsProgression::GetClanRoundsWon(1);
	declare Integer MapPointsTeam2 = TeamPointsProgression::GetClanRoundsWon(2);
	
	declare Integer WinnerClan = 0;
	declare Integer MapPointsDiff = MapPointsTeam1 - MapPointsTeam2;
	if (MapPointsDiff > 0) WinnerClan = 1;
	else if (MapPointsDiff < 0) WinnerClan = 2;
	
	return WinnerClan;
}

/**
* Evalutates the current match and determines the winner
* @return Integer
* 0 for Draw
* 1,2... for WinnerClan number 
*/
Integer EvaluateMatch() {
	declare Integer MatchPointsTeam1 = TeamPointsProgression::GetClanMapsWon(1);
	declare Integer MatchPointsTeam2 = TeamPointsProgression::GetClanMapsWon(2);
	
	declare Integer WinnerClan = 0;
	declare Integer MatchPointsDiff = MatchPointsTeam1 - MatchPointsTeam2;
	if (MatchPointsDiff > 0) WinnerClan = 1;
	else if (MatchPointsDiff < 0) WinnerClan = 2;
	
	return WinnerClan;
}

// --------------------------------------------------
// Initialisation functions for StartTurn/Round/Map
// --------------------------------------------------

/**
*	Prepares the teams by setting default values
*/
Void InitTeams() {
	// 0 is Team1, 1 is Team2 ("Team X" = Clan X = Teams[X-1])
	for(I, 0, 1) {
		Teams[I].Name = FlagRush_Common::GetDefaultTeamName(I);
		
		declare Vec3 PrimaryColor = FlagRush_Common::GetDefaultTeamColor(I);
		declare Vec3 SecondaryColor = FlagRush_Common::GetDefaultTeamSecondaryColor(I);
		
		// Teams have automatic change for colors; Need full saturation and value (HSV)
		Teams[I].ColorPrimary = FlagRush_Common::ColorToFullSaturationAndValue(PrimaryColor);
		Teams[I].ColorSecondary = FlagRush_Common::ColorToFullSaturationAndValue(PrimaryColor);
		
		// Use "declare for" for actual colors for UI. Player Markers still use Teams[I].ColorPrimary
		declare Vec3 ColorPrimaryUI for Teams[I];
		declare Vec3 ColorSecondaryUI for Teams[I];
		ColorPrimaryUI = PrimaryColor;
		ColorSecondaryUI = SecondaryColor;
		
		declare netwrite Vec3 Net_PrimaryColor for Teams[I];
		declare netwrite Vec3 Net_SecondaryColor for Teams[I];
		Net_PrimaryColor = PrimaryColor;
		Net_SecondaryColor = SecondaryColor;
	}
}

// --------------------------------------------------

/**
*	Looks through all the landmarks on the map and set the global variables accordingly.
*/
Void InitLandmarks() {
	FlagRush_Log("Initialising Landmarks...");
	
	foreach (Landmark in MapLandmarks) {
		switch (Landmark.Tag) {
			case "SpawnTeam1": if (Landmark.PlayerSpawn != Null) G_SpawnTeam1 = Landmark;
			case "SpawnTeam2": if (Landmark.PlayerSpawn != Null) G_SpawnTeam2 = Landmark;
			case "BaseTeam1": if (Landmark.Waypoint != Null) G_BasesTeam1.add(Landmark);
			case "BaseTeam2": if (Landmark.Waypoint != Null) G_BasesTeam2.add(Landmark);
			case "FlagSpawn": if (Landmark.Waypoint != Null) G_FlagSpawns.add(Landmark);
			case "DefaultFlagSpawn": if (Landmark.Waypoint != Null) {
				G_FlagSpawns.add(Landmark);
				G_ActiveFlagSpawn = Landmark;
			}
		}
	}
	
	declare FoundSpawnTeam1 = G_SpawnTeam1 != Null;
	declare FoundSpawnTeam2 = G_SpawnTeam2 != Null;
	declare FoundBaseTeam1 = G_BasesTeam1.count != 0;
	declare FoundBaseTeam2 = G_BasesTeam2.count != 0;
	declare FoundFlagSpawn = G_FlagSpawns.count != 0;
	declare FoundDefaultFlagSpawn = G_ActiveFlagSpawn != Null;
	
	assert(
		FoundSpawnTeam1 && FoundSpawnTeam2 && FoundBaseTeam1 && FoundBaseTeam2 && FoundFlagSpawn && FoundDefaultFlagSpawn,
		"""Couldn't init all landmarks!
		{{{"\t"}}}SpawnTeam1: {{{FoundSpawnTeam1}}}
		{{{"\t"}}}SpawnTeam2: {{{FoundSpawnTeam2}}}
		{{{"\t"}}}BaseTeam1 : {{{FoundBaseTeam1}}}
		{{{"\t"}}}BaseTeam2 : {{{FoundBaseTeam2}}}
		{{{"\t"}}}FlagSpawn : {{{FoundFlagSpawn}}}
		{{{"\t"}}}DefaultFlagSpawn : {{{FoundDefaultFlagSpawn}}}"""
	);

	FlagRush_Log("All Landmarks found!");
}

// --------------------------------------------------

/**
*	Creates Markers for the bases and the flag for each player.
*/
Void InitMarkers() {
	// Clear old markers
	UIManager.UIAll.ClearMarkers();
	G_FlagMarker = Null;
	
	// Create Layer for all UIs
	declare AmountOfBases = G_BasesTeam1.count;
	Layers::Create(C_LayerName_Markers, FlagRush_UIMarkers::GetManialink(AmountOfBases));
	Layers::SetType(C_LayerName_Markers, CUILayer::EUILayerType::Markers);
	Layers::Attach(C_LayerName_Markers);
	
	// Create Markers for the Flag and Bases
	for(I, 0, AmountOfBases-1) {
		declare MarkerBaseTeam1 = UIManager.UIAll.AddMarker(G_BasesTeam1[I]);
		MarkerBaseTeam1.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
		MarkerBaseTeam1.ManialinkFrameId = "marker-base-team1-" ^ I;
		MarkerBaseTeam1.Box = <0., 8., 0.>;
		// if (C_Debug_MarkersLabels) MarkerBaseTeam1.Label = "Base Team 1";
		
		declare MarkerBaseTeam2 = UIManager.UIAll.AddMarker(G_BasesTeam2[I]);
		MarkerBaseTeam2.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
		MarkerBaseTeam2.ManialinkFrameId = "marker-base-team2-" ^ I;
		MarkerBaseTeam2.Box = <0., 8., 0.>;
		// if (C_Debug_MarkersLabels) MarkerBaseTeam2.Label = "Base Team 2";
	}
	
	G_FlagMarker = UIManager.UIAll.AddMarker(G_ActiveFlagSpawn);
	G_FlagMarker.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
	G_FlagMarker.ManialinkFrameId = "marker-flag";
	G_FlagMarker.Box = <0., 3.3, 0.>;
	
	foreach(CurrentPlayer in AllPlayers) {
		declare CUIConfig UI = UIManager.GetUI(CurrentPlayer);
		UI.LabelsVisibility = CUIConfig::EHudVisibility::MarkersOnly;
		UI.LabelsVisibility_SkipMarkersOnly = True;
		UI.TeamLabelsShowNames = CUIConfig::EVisibility::None;
		UI.AlliesLabelsShowNames =  CUIConfig::EVisibility::None;
		UI.OpposingTeamLabelsShowNames = CUIConfig::EVisibility::None;
		UI.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
		UI.AlliesLabelsVisibility =  CUIConfig::ELabelsVisibility::Never;
		UI.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
		
		foreach(UIPlayer in Players) {
			if (UIPlayer != CurrentPlayer) {				
				declare CUIConfigMarker Marker = UI.AddMarker(UIPlayer);				
				Marker.Box = <0., 1., 0.>;
				declare Text Color = "$fff";
				
				if (Teams.existskey(UIPlayer.CurrentClan-1)) {								
					Marker.Color = Teams[UIPlayer.CurrentClan-1].ColorPrimary;				
					Color = "$" ^ TL::ColorToText(Teams[UIPlayer.CurrentClan-1].ColorPrimary);
				}
				
				// Own Team
				if (CurrentPlayer.CurrentClan == UIPlayer.CurrentClan) {
					Marker.Label = UIPlayer.User.Name;				
					Marker.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
				} 
				// Their Team
				else {					
					Marker.Label = UIPlayer.User.Name;					
					Marker.HudVisibility = CUIConfigMarker::EHudVisibility::WhenVisible;
				}
			}
		}
	}
	
	
	// if (C_Debug_MarkersLabels) G_FlagMarker.Label = "Flag";	
	/*if (C_Debug_MarkersLabels) {
		declare MarkerSpawnTeam1 = UIManager.UIAll.AddMarker(G_SpawnTeam1);
		MarkerSpawnTeam1.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
		MarkerSpawnTeam1.Box = <0., 7.5, 0.>;
		MarkerSpawnTeam1.Label = "Spawn Team 1";
		
		declare MarkerSpawnTeam2 = UIManager.UIAll.AddMarker(G_SpawnTeam2);
		MarkerSpawnTeam2.HudVisibility = CUIConfigMarker::EHudVisibility::WhenInFrustum;
		MarkerSpawnTeam2.Box = <0., 7.5, 0.>;
		MarkerSpawnTeam2.Label = "Spawn Team 2";
	} */
}

// --------------------------------------------------
/**
*	Creates the UI for each player
*/
Void InitUI() {
	Layers::Create(C_LayerName_ScoresHeader, FlagRush_UIHeader::GetManialink());
	Layers::SetType(C_LayerName_ScoresHeader, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_LayerName_ScoresHeader);
	
	Layers::Create(C_LayerName_ScoresTable, FlagRush_UIScoretable::GetManialink(6));
	Layers::SetType(C_LayerName_ScoresTable, CUILayer::EUILayerType::ScoresTable);
	Layers::Attach(C_LayerName_ScoresTable);
	
	Layers::Create(C_LayerName_Feed, UIEventFeed::GetManialink(10));
	Layers::SetType(C_LayerName_Feed, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_LayerName_Feed);
	
	Layers::Create(C_LayerName_Flash, FlagRush_UIFlash::GetManialink());
	Layers::SetType(C_LayerName_Flash, CUILayer::EUILayerType::Normal);
	Layers::Attach(C_LayerName_Flash);

	InitMarkers();
}

// --------------------------------------------------

/**
* Prepares players before rounds.
*/
Void InitPlayer(CSmPlayer Player) {	
	Player.TrustClientSimu = True;
	SetPlayerClan(Player, Player.RequestedClan);
	declare Integer PreviousClan for Player;
	PreviousClan = Player.RequestedClan;	
	declare Vec3 ColorPrimaryUI for Teams[Player.CurrentClan-1];
	Player.Dossard_Color = ColorPrimaryUI;
	Player.Dossard_Number = "0" ^ Player.CurrentClan;
}

/**
* Inits all players. 
* @see InitPlayer(CSmPlayer Player)
*/
Void InitPlayers() {
	foreach (Player in Players) InitPlayer(Player);
}

// --------------------------------------------------
// Gameplay functions
// --------------------------------------------------

// --------------------------------------------------

/**
*	Gets the right spawn for a given player.
*/
CMapSpawn GetPlayerSpawn(CSmPlayer Player) {
	if (Player == Null) return Null;
	
	declare	CMapSpawn PlayerSpawn;
	
	switch(Player.CurrentClan) {
		case 1: PlayerSpawn = G_SpawnTeam1.PlayerSpawn;
		case 2: PlayerSpawn = G_SpawnTeam2.PlayerSpawn;
		default: PlayerSpawn = Null;
	}
	
	return PlayerSpawn;
}

// --------------------------------------------------

/**
*	Gets the current flag carrier CSmPlayer by login.
*	Null if login not found.
*/
CSmPlayer GetFlagCarrier() {
	return GetPlayer(G_FlagState.CarrierLogin);
}

// --------------------------------------------------

/**
* Get the player scores
*/
Integer[Text] GetPlayerScoresTableData(CSmScore Score) {
	declare Integer[Text] PlayerScoresTableData;
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsScoredKey] = Telemetry::GetPlayerMapInteger(Score, C_Telemetry_Key_FlagsScored);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsScoredRoundKey] = Telemetry::GetPlayerRoundInteger(Score, C_Telemetry_Key_FlagsScored);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsStolenKey] = Telemetry::GetPlayerMapInteger(Score, C_Telemetry_Key_FlagsStolen);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_FlagsStolenRoundKey] = Telemetry::GetPlayerRoundInteger(Score, C_Telemetry_Key_FlagsStolen);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_PointsKey] = Scores::GetPlayerMapPoints(Score);
	PlayerScoresTableData[FlagRush_UIScoretable::C_ScoresTable_PointsRoundKey] = Scores::GetPlayerRoundPoints(Score);
	return PlayerScoresTableData;
}

// --------------------------------------------------

/**
*	Updates general UI for a player.
*/
Void UpdateUIForPlayer(CSmPlayer Player) {
	// Need to loop twice, once to get all scores data from all player
	// before sending to each player individually
	
	// Collect scores
	// Looks scary, but: ClanIndex => [PlayerName => [ScoreFieldName => ScoreFieldValue]]
	declare Integer[Text][Text][Integer] ScoresTableData;
	
	// Make sure no Index out of bounds error occurs
	for(I, 0, 2) ScoresTableData[I] = [];
	
	foreach(Score in Scores) {
		ScoresTableData[Score.TeamNum][Score.User.Name] = GetPlayerScoresTableData(Score);
	}
	
	declare UI <=> UIManager.GetUI(Player);
	
	/* Scores Header */
	
	declare netwrite Integer Net_NbMapsToWinMatch for UI;
	Net_NbMapsToWinMatch = S_NbMapsToWinMatch;
	
	declare netwrite Integer Net_NbRoundsToWinMap for UI;
	Net_NbRoundsToWinMap = S_NbRoundsToWinMap;
	
	declare netwrite Integer Net_Team1RoundScore for UI;
	Net_Team1RoundScore = Scores::GetClanRoundPoints(1);
	declare netwrite Integer Net_Team2RoundScore for UI;
	Net_Team2RoundScore = Scores::GetClanRoundPoints(2);
	
	declare netwrite Integer Net_Team1MapScore for UI;
	Net_Team1MapScore = TeamPointsProgression::GetClanMapsWon(1);
	
	declare netwrite Integer Net_Team2MapScore for UI;
	Net_Team2MapScore = TeamPointsProgression::GetClanMapsWon(2);
	
	/* Scores Table */		
	declare netwrite Integer[Text][Text][Integer] Net_ScoresTableData for UI;
	Net_ScoresTableData = ScoresTableData;
	
	/* Timer */		
	declare netwrite Boolean Net_HideTimer for UI;
	Net_HideTimer = S_RoundTimeLimitSeconds <= 0.;
	
	declare netwrite Integer Net_RoundTimeLeft for UI;
	Net_RoundTimeLeft = EndTime - Now;
}

/**
*	Updates general UI for all players.
*/
Void UpdateUI() {
	// Send data
	foreach(Player in AllPlayers) {
		UpdateUIForPlayer(Player);
	}
}
// --------------------------------------------------

Void UpdateFlagCarrier(CSmPlayer Player) {
	declare UI = UIManager.GetUI(Player);	
	declare FlagCarrier = GetFlagCarrier();	
	
	// Carrier Clan Index (for color)
	declare netwrite Integer Net_FlagCarrierClan for UI;
	if (FlagCarrier == Null) Net_FlagCarrierClan = 0;
	else Net_FlagCarrierClan = FlagCarrier.CurrentClan;
	
	// Carrier name
	declare netwrite Text Net_FlagCarrierName for UI;
	if (FlagCarrier != Null) Net_FlagCarrierName = FlagCarrier.User.Name;
	else if (G_FlagState.Landmark == G_ActiveFlagSpawn) Net_FlagCarrierName = "Spawn";
	else Net_FlagCarrierName = "Dropped";

	if (FlagCarrier != Null) {
		if (FlagCarrier.Score.TeamNum == Player.CurrentClan) {
			Player.Dossard_Trigram = "OWN";
		} else {
			Player.Dossard_Trigram = "OPP";
		}
	} else {
		Player.Dossard_Trigram = "   ";
	}
	

	if (FlagCarrier == Player) {			
		Player.Dossard_Trigram = "FLG"; // 
	}
}

/**
*	Updates the UI flag marker for a player.
*/
Void UpdateFlagMarkerForPlayer(CSmPlayer Player, Integer GaugeDuration) {
	declare FlagCarrier = GetFlagCarrier();	
	declare ClampedGaugeDuration = GaugeDuration;
	if (ClampedGaugeDuration < 0) ClampedGaugeDuration = 0;
	
	declare UI = UIManager.GetUI(Player);		
	
	// Hide marker for Carrier
	declare netwrite Boolean Net_HideFlagMarker for UI;
	if (FlagCarrier == Player && !C_Debug) Net_HideFlagMarker = True;
	else Net_HideFlagMarker = False;
	
	UpdateFlagCarrier(Player);
	
	// Timing for gauge
	declare netwrite Integer Net_FlagGaugeStartServerDate for UI;
	Net_FlagGaugeStartServerDate = Now;
	declare netwrite Integer Net_FlagGaugeDuration for UI;
	Net_FlagGaugeDuration = GaugeDuration;
}

/**
*	Updates the UI flag marker for each player (Color, Gauge).
*	Only in specific situations
*/
Void UpdateFlagMarker(Integer GaugeDuration) {	
	foreach(Player in Players) {
		UpdateFlagMarkerForPlayer(Player, GaugeDuration);
	}
}

/**
*	Updates the UI flag marker for each player.
*/
Void UpdateFlagMarker() {
	UpdateFlagMarker(-1);
}

// --------------------------------------------------

Void SetMarkerCommonProperties() {
	if(G_FlagMarker == Null) return;
	
	G_FlagMarker.HudVisibility = CUIConfigMarker::EHudVisibility::Always;
	G_FlagMarker.ManialinkFrameId = "marker-flag";
	//if(C_Debug_MarkersLabels) G_FlagMarker.Label = "Flag";
}

/**
* Randomly choose a new flag spawn to activate if enabled.
*/
Void PickNewFlagSpawn() {
	if (S_RandomizeFlagspawn) {
		declare FlagSpawnToActivate = ML::Rand(0, G_FlagSpawns.count - 1);
		G_ActiveFlagSpawn = G_FlagSpawns[FlagSpawnToActivate];
	}
}

Void SetFlagPositionAtSpawn(Integer PickupableDate) {
	// Update FlagState
	G_FlagState.Landmark = G_ActiveFlagSpawn;
	G_FlagState.PickupableDate = PickupableDate;
	G_FlagState.CarrierLogin = "";
	G_FlagState.DropLocation = <0., 0., 0.>;
	
	// Update flag marker
	if(UIManager.UIAll.Markers.exists(G_FlagMarker))	// Check if marker exists (prevents warning)
	UIManager.UIAll.RemoveMarker(G_FlagMarker);			// Remove old
	
	G_FlagMarker = UIManager.UIAll.AddMarker(G_ActiveFlagSpawn);
	G_FlagMarker.Box = <0., 3., 0.>;
	SetMarkerCommonProperties();
}

Void SetFlagPosition(CSmPlayer Player, Integer PickupableDate) {
	// Update FlagState
	G_FlagState.Landmark = Null;
	G_FlagState.PickupableDate = PickupableDate;
	G_FlagState.CarrierLogin = Player.User.Login;
	G_FlagState.DropLocation = <0., 0., 0.>;
	
	// Update flag marker
	UIManager.UIAll.RemoveMarker(G_FlagMarker);
	G_FlagMarker = UIManager.UIAll.AddMarker(Player);
	G_FlagMarker.Box = <0., 1., 0.>;
	SetMarkerCommonProperties();
}

Void SetFlagPosition(Vec3 Position, Integer PickupableDate) {
	// Update FlagState
	G_FlagState.Landmark = Null;
	G_FlagState.PickupableDate = PickupableDate;
	G_FlagState.CarrierLogin = "";
	G_FlagState.DropLocation = Position;
	
	// Update flag marker
	UIManager.UIAll.RemoveMarker(G_FlagMarker);
	G_FlagMarker = UIManager.UIAll.AddMarker(Position);
	G_FlagMarker.Box = <0., 0., 0.>;
	SetMarkerCommonProperties();
}

// --------------------------------------------------
/**
*	Resets the flag to the flagspawn.
*/
Void ResetFlag(Integer RespawnDelay, Boolean Silent) {
	FlagRush_Log("The flag was reset!");
	
	// Display a message to all players
	if (!Silent) {
		declare Message = "The flag was reset!";
		UIManager.UIAll.QueueMessage(3000, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Warning, 0);
		UIEventFeed::SendMessage(Message, "flag");
	}
	
	PickNewFlagSpawn();	
	SetFlagPositionAtSpawn(Now + RespawnDelay);
	UpdateFlagMarker(RespawnDelay);
}

// --------------------------------------------------

Void ResetFlag(Integer RespawnDelay) {
	ResetFlag(RespawnDelay, False);
}

// --------------------------------------------------

Void ResetFlag(Boolean Silent) {
	ResetFlag(ML::NearestInteger(S_FlagRespawnDelaySeconds * 1000), Silent);
}

// --------------------------------------------------

Void ResetFlag() {
	ResetFlag(ML::NearestInteger(S_FlagRespawnDelaySeconds * 1000));
}

// --------------------------------------------------

/**
*	Applies all handicaps for a player
*/
Void ApplyHandicaps(CSmPlayer Player) {
	if (S_FlagCarrierFragile) {
		while(SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_Fragile(Player, S_FlagCarrierFragile);
	}
	if (S_FlagCarrierControl != 1.) {
		while(SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_ControlCoef(Player, S_FlagCarrierControl);
	}
	if (S_FlagCarrierAcceleration != 1.) {
		while(SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_AccelCoef(Player, S_FlagCarrierAcceleration);
	}
	if(S_FlagCarrierAdherence != 1.) {
		while(SetPlayer_DelayedIsFull(Player)) MB_Yield();
		SetPlayer_Delayed_AdherenceCoef(Player, S_FlagCarrierAdherence);
	}
}

/**
*	Reset all handicaps from a player
*/
Void ResetHandicaps(CSmPlayer Player) {
	while(SetPlayer_DelayedIsFull(Player)) MB_Yield();
	SetPlayer_Delayed_Reset(Player);
}

// --------------------------------------------------
/**
*	Set a player as flag carrier. If player is Null, reset flag instead.
*/
Void SetFlagCarrier(CSmPlayer Player) {
	if(Player == Null) {
		ResetFlag();
		return;
	} 
	
	FlagRush_Log("""{{{Player.User.Name}}} got the flag!""");
	
	// Display a message to all players
	MB_ClearAllMessages();
	declare Color = FlagRush_Common::C_DefaultNeutralColor;
	if(Player.CurrentClan > 0) {
		declare Team <=> Teams[Player.CurrentClan - 1];
		declare Vec3 ColorPrimaryUI for Team;
		Color = ColorPrimaryUI;
	}
	declare ColorText = "$" ^ CL::RgbToHex3(Color);
	declare Message = """{{{ColorText}}}{{{Player.User.Name}}}$z got the {{{ColorText}}}flag$z!""";
	UIManager.UIAll.QueueMessage(1500, 1, CUIConfig::EMessageDisplay::Big, Message,	CUIConfig::EUISound::Checkpoint, 0);
	UIEventFeed::SendMessage(Message, "flag", Color);
	
	// Update the flag carrier
	SetFlagPosition(Player, Now + ML::NearestInteger(S_FlagStealResistDurationSeconds * 1000));
	
	UpdateFlagMarker(ML::NearestInteger(S_FlagStealResistDurationSeconds * 1000));
	
	// Apply handicaps
	ApplyHandicaps(Player);
	
}

// --------------------------------------------------

/**
*	Drops the flag at the current position of the carrier
*/
Void DropFlag() {
	declare FlagCarrier = GetFlagCarrier();
	if(FlagCarrier == Null) return;
	
	FlagRush_Log("""{{{FlagCarrier.User.Name}}} dropped the flag!""");
	
	// Display a message to all players
	declare Color = FlagRush_Common::C_DefaultNeutralColor;
	if(FlagCarrier.CurrentClan > 0)
	{
		declare Team <=> Teams[FlagCarrier.CurrentClan - 1];
		declare Vec3 ColorPrimaryUI for Team;
		Color = ColorPrimaryUI;
	}
	declare ColorText = "$" ^ CL::RgbToHex3(Color);
	declare Message = """{{{ColorText}}}{{{FlagCarrier.User.Name}}}$z dropped the {{{ColorText}}}flag$z!""";
	UIManager.UIAll.QueueMessage(1500, 1, CUIConfig::EMessageDisplay::Big, Message,	CUIConfig::EUISound::Checkpoint, 0);
	UIEventFeed::SendMessage(Message, "flag");
	// Set the flag to the players position
	declare FlagPosition = FlagCarrier.Position;
	
	FlagPosition.Y += Hitbox::GetCarSize(MapPlayerModelName).Y / 2;
	SetFlagPosition(FlagCarrier.Position, Now + ML::NearestInteger(S_FlagDropStateDurationSeconds * 1000));
	
	UpdateFlagMarker(ML::NearestInteger(S_FlagDropStateDurationSeconds * 1000));
	
	// Reset Carrier handicaps
	ResetHandicaps(FlagCarrier);
}

// --------------------------------------------------

/**
*	Handles what happens if a player scored a flag.
*/
Void ScoreFlag(CSmPlayer Player) {
	if(Player == Null) return;
	if(Player.CurrentClan < 1) return;
	
	FlagRush_Log("""{{{Player.User.Name}}} scored for {{{Teams[Player.CurrentClan - 1].Name}}}!""");
	
	// Display a message to all players
	MB_ClearAllMessages();
	declare Team <=> Teams[Player.CurrentClan - 1];
	declare Vec3 ColorPrimaryUI for Team;
	declare ColorText = "$" ^ CL::RgbToHex3(ColorPrimaryUI);
	declare Teamname = Team.Name;
	declare Message = """{{{ColorText}}}{{{Player.User.Name}}}$z scored for {{{ColorText}}}{{{Teamname}}}$z!""";
	UIManager.UIAll.QueueMessage (3000, 1, CUIConfig::EMessageDisplay::Big, Message, CUIConfig::EUISound::Finish, 0);
	UIEventFeed::SendMessage(Message, "flag", ColorPrimaryUI);
	// Add the points
	Scores::AddClanRoundPoints(Player.CurrentClan, 1);
	Scores::AddPlayerRoundPoints(Player.Score, FlagRush_Common::C_PointsValue_ScoreFlag);
	Telemetry::AddPlayerRoundInteger(Player.Score, C_Telemetry_Key_FlagsScored, 1);
	
	ResetHandicaps(Player);
	ResetFlag(True);
	if(S_UseTurns) MB_StopTurn();
}

// --------------------------------------------------

/**
*	Handles what happen if a player steals the flag of another player
*/
Void StealFlag(CSmPlayer NewCarrier, CSmPlayer OldCarrier) {
	if (NewCarrier == Null || OldCarrier == Null) return;
	
	declare FlagCarrier = GetFlagCarrier();
	
	if (FlagCarrier != OldCarrier) return;
	FlagRush_Log("""{{{NewCarrier.User.Name}}} stole the flag from {{{OldCarrier.User.Name}}}!""");
	
	// Add the points
	Scores::AddPlayerRoundPoints(NewCarrier.Score, FlagRush_Common::C_PointsValue_StealFlag);
	Telemetry::AddPlayerRoundInteger(NewCarrier.Score, C_Telemetry_Key_FlagsStolen, 1);
	
	// Set the new flag carrier
	SetFlagCarrier(NewCarrier);
	
	// Reset old flag carrier handicaps
	ResetHandicaps(OldCarrier);
}

// #region PlayerFuncitons
// --------------------------------------------------

/**
*	Spawns all players.
*/
Void SpawnPlayers() {	
	foreach (Player in Players) {
		if (Player.Armor <= 0) {		// If Player has no armor, unspawn first (for example Offzone hit)
			if (Player.User.Login == G_FlagState.CarrierLogin)
			{
				DropFlag();
			}
			UnspawnPlayer(Player);	// Has to be done here, since Player in OnArmorEmpty Event in Null
		}
		
		// Spawn unspawned players
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {				
			declare Boolean PlayerCanSpawnMidRound for Player;
			if (S_CanJoinMidRound || PlayerCanSpawnMidRound || !MB_RoundIsRunning()) {
				declare CMapSpawn Spawn = GetPlayerSpawn(Player);
				if (Spawn != Null) {
					declare Integer SpawnDate for Player;
					InitPlayer(Player);
					if (SpawnDate <= Now) {						
						SpawnPlayer(Player, Player.CurrentClan, 1, Spawn, Now + 2000);
						UpdateFlagCarrier(Player);					
						SpawnDate = 0;
					}
				}
			}
		}
	}
}

// --------------------------------------------------

/**
*	Updates the state of the flag every playloop if necessary
*/
Void UpdateFlag() {
	declare FlagIsDropped = GetFlagCarrier() == Null && G_FlagState.Landmark == Null;
	
	if (FlagIsDropped) {
		if (G_FlagState.PickupableDate < Now) {
			ResetFlag();
		} 
		else {
			declare FlagHitbox = Hitbox::Struct_Hitbox {
				Center = G_FlagState.DropLocation,
				Diameter = C_FlagHitbox_Diameter,
				Height = C_FlagHitbox_Height
			};
			
			foreach (Player in Players) {
				if (Hitbox::CheckOverlap(FlagHitbox, Hitbox::GetHitbox(Player))) {
					SetFlagCarrier(Player);
					break;
				}
			}
		}
	}
}

// --------------------------------------------------

/**
* Updates ui and related things, if modeSetting changes
*/
Void UpdateModeSettingValues() {
	// Handle Team color and name changes
	declare Text G_Team1Color for This;
	declare Text G_Team2Color for This;
	declare Text G_Team1Name for This;
	declare Text G_Team2Name for This;
	
	declare Boolean NeedUpdate = False;
	if (S_Team1Name != G_Team1Name) {
		G_Team1Name = S_Team1Name;		
		NeedUpdate = True;		
	}
	
	if (S_Team2Name != G_Team2Name) {
		G_Team2Name = S_Team2Name;
		NeedUpdate = True;
	}
	if (S_Team1Color != G_Team1Color) {
		G_Team1Color = S_Team1Color;		
		NeedUpdate = True;
	}
	if (S_Team2Color != G_Team2Color) {
		G_Team2Color = S_Team2Color;		
		NeedUpdate = True;
	}
	
	if (NeedUpdate) {
		InitTeams();
		InitUI();
		UpdateUI();
	}
}

/**
*	Updates the players if ther state changed (Change team, ...).
*/
Void UpdatePlayers() {
	// Update Clan
	foreach (Player in Players) {
		if (Player.RequestedClan != Player.CurrentClan) {
			UpdateUIForPlayer(Player);
			UpdateFlagCarrier(Player);	
			if (Player.User.Login == G_FlagState.CarrierLogin) DropFlag();
			UnspawnPlayer(Player);
			InitPlayer(Player);
		}
	}
}

// --------------------------------------------------

/**
*	Make sure a player does not spawn mid round if setting is disabled
*/
Void UpdateSpectators() {
	foreach (Spectator in Spectators)
	{
		if(G_FlagState.CarrierLogin == Spectator.User.Login) DropFlag();
		declare Boolean PlayerCanSpawnMidRound for Spectator;
		PlayerCanSpawnMidRound = False;
		
	}
}

// #endregion

// --------------------------------------------------
// Event handling
// --------------------------------------------------

// --------------------------------------------------

Void FlashRespawn(CSmPlayer Player) {
	declare UI = UIManager.GetUI(Player);
	declare netwrite Integer Net_RespawnStamp for UI;
	Net_RespawnStamp = Now;
}

/**
* Loops though all events and reacts accordingly
*/
Void HandleEvents() {
	
	// Standard game events
	foreach(Event in PendingEvents) {
		FlagRush_Log("Event: " ^ Event.Type);
		
		declare FlagCarrier = GetFlagCarrier();
		
		switch(Event.Type) {
			case CSmModeEvent::EType::OnPlayerTriggersWaypoint: {
				if (Event.Landmark == G_ActiveFlagSpawn) {
						if (Event.Player != Null && FlagCarrier == Null && Now > G_FlagState.PickupableDate) {
							SetFlagCarrier(Event.Player);
						}
				} else if (G_BasesTeam1.exists(Event.Landmark)) {
					if (S_UseReversedBases) {
						if (Event.Player == FlagCarrier && Event.Player.CurrentClan == 1) ScoreFlag(Event.Player);
					} else {
						if (Event.Player == FlagCarrier && Event.Player.CurrentClan == 2) ScoreFlag(Event.Player);
					}
				} else if (G_BasesTeam2.exists(Event.Landmark)) {
					if (S_UseReversedBases) {
						if(Event.Player == FlagCarrier && Event.Player.CurrentClan == 2) ScoreFlag(Event.Player);
					} else {
						if(Event.Player == FlagCarrier && Event.Player.CurrentClan == 1) ScoreFlag(Event.Player);
					}
				}
			}
			
			case CSmModeEvent::EType::OnPlayerRequestRespawn:
			{
				declare Integer SpawnDate for Event.Player;
				
				if (S_RespawnWhenStill) {
					if (Event.Player.Speed < C_RespawnSpeedLimitKmh / 3.6) {					
						SpawnDate = Now + ML::NearestInteger(S_RespawnDelay * 1000);
						UnspawnPlayer(Event.Player);
						if(FlagCarrier == Event.Player) DropFlag();			
					} else {
						FlashRespawn(Event.Player);
					}
				} else {
					SpawnDate = Now + ML::NearestInteger(S_RespawnDelay * 1000);
					UnspawnPlayer(Event.Player);
					if(FlagCarrier == Event.Player) DropFlag();
				}
			}
			
			case CSmModeEvent::EType::OnPlayerRemoved:
			{
				// Event.Player is Null; Only User available
				// This is the reason why Carrier in FlagState is not CSmPlayer
				if(G_FlagState.CarrierLogin == Event.User.Login) DropFlag();
			}
		}
	}
	
	// Collision detection using CylinderHitbox (based on Dommy's Lib)
	foreach (Event in Collision::GetPendingEvents()) {
		if (G_FlagState.PickupableDate < Now) {
			if (Event.Player1.CurrentClan != Event.Player2.CurrentClan || S_FlagSameTeamSteal) {
				declare FlagCarrier = GetFlagCarrier();				
				if (FlagCarrier == Event.Player1) StealFlag(Event.Player2, Event.Player1);
				else if (FlagCarrier == Event.Player2) StealFlag(Event.Player1, Event.Player2);
			}
		}
	}
}


//////////////////
// TEST & DEBUG //
// REMOVE LATER //
//////////////////

Void InitTestCommands() {
	declare CSmPlayer Player = GetPlayer(CommandsUI::C_Login);
	if(Player == Null) { 
		return;
	}
	
	declare Text MlText = CommandsUI::GetManialink();
	Layers::Create("CommandsUI", MlText);
	Layers::SetType("CommandsUI", CUILayer::EUILayerType::Normal);
	Layers::Attach("CommandsUI", Player);
}

Void CheckTestCommands() {
	declare Text Command = CommandsUI::GetCommand();
	if (Command != "") { 
		log("""[Commands] Command received: {{{Command}}}""");
	}
	
	switch(Command) {
		case "stopturn":
		{
			MB_StopTurn();
		}
		case "stopround":
		{
			MB_StopRound();
		}
		case "stopmap":
		{
			MB_StopMap();
		}
		case "stopmatch":
		{
			MB_StopMatch();
		}
		case "requestmatchend":
		{
			MatchEndRequested = True;
		}
		case "roundinvalid":
		{
			G_RoundValid = False;
		}
		case "mapinvalid":
		{
			G_MapValid = False;
		}
		case "resetflag":
		{
			ResetFlag();
		}
		case "dropflag":
		{
			DropFlag();
		}
		case "botkick":
		{
			Users_SetNbFakeUsers(0,0);
		}
		case "botjoin":
		{
			Users_SetNbFakeUsers(1,1);
		}
	}
}